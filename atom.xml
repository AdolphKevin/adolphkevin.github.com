<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>闹闹吃鱼</title>
  
  <subtitle>闹闹</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://AdolphKevin.github.io/"/>
  <updated>2019-08-05T18:22:12.772Z</updated>
  <id>https://AdolphKevin.github.io/</id>
  
  <author>
    <name>闹闹</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>小公司的坑，能躲一个是一个！</title>
    <link href="https://AdolphKevin.github.io/2019/08/06/%E5%B0%8F%E5%85%AC%E5%8F%B8%E7%9A%84%E5%9D%91%EF%BC%8C%E8%83%BD%E8%BA%B2%E4%B8%80%E4%B8%AA%E6%98%AF%E4%B8%80%E4%B8%AA%EF%BC%81/"/>
    <id>https://AdolphKevin.github.io/2019/08/06/小公司的坑，能躲一个是一个！/</id>
    <published>2019-08-05T18:12:00.000Z</published>
    <updated>2019-08-05T18:22:12.772Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/007OROpSgy1g5pbwts9dkj30hd0cqdhe.jpg" alt></p><p>马上就金九银十了，想必找工作的人也特别多</p><p>这几天在搜一些市场招聘信息，了解了下市场的需求后，这就来煲碗毒鸡汤</p><p>大公司与小公司的选择，是绝大多数人难以抉择的一个问题</p><p>其实放到今天来看，这个问题其实已经不再是问题了</p><p>先说下结论吧，如果没有大公司背景，没有5年以上的工作经验，那么<strong>能去大公司就去大公司，基本可以不考虑小公司</strong></p><p>先说下我对大小公司的定义吧，研发团队人数能高于100人，就不能说是小公司了，而研发团队的人数小于二十人，就可以算做是小公司</p><p>这数字也不是平白无故瞎说的，因为在大公司里，一个软件的开发也是分为了若干个项目组，一个项目组一般情况不会超过二十人，都是各个项目组各自负责一部分</p><p>之所以这样，就是因为现在行业内对专业性人才的需求越来越高，再也不像好几年前那样，一个人负责多个模块</p><p>我们仔细观察自己身边的各行各业，就会很明显的发现，各行各业都有自己的细分领域，其实行业细分化很早之前就有趋势了，只是现如今的感知越来越明显罢了</p><p>简单说说我们做技术的细分领域发展，从前几年非常吃香的全栈，到现如今，那些在单个领域更精通的人才，反倒是更受欢迎，比如从岗位上来看，光是前端就区分了UI设计，UX设计，UED设计，前端架构师等等</p><p>「专业的事情交给专业的人来做」这句话就充分体现了当下社会对人才的需求，并不是不再需要什么都会点儿的全栈，而是<strong>更需要</strong>在单个领域里能有着一定深度的专家</p><p>要成为一个行业的专家，从10万小时理论来说，差不多得要十年的时间</p><p>如果想要做一个全栈，要学会设计，前端，后台，数据库，服务器，操作系统。就算六个领域好了，这就得60年。。。</p><p>咱们从18岁进入大学后学编程开始计算，工作到65岁退休，也只有47年的时间，要是没有很高的天赋，想要30岁之前成为一个全栈专家，这基本是不可能</p><p>而只要专注于一个领域，花上十年时间，30岁成为某一个领域中的专家，只要自己不放弃，基本人人都能做到</p><p>可现实却是，大多数人最缺的就是专注和耐心。做着前端的时候想着后端的好，做着后端的想着自己要做个程序创业，要去学数据库和前端</p><p>在大家都没耐心的情况下，我们根本就不需要拼天赋，只要专注并且有耐心，就能超越绝大多数人</p><p>好了，扯远了，现在说说为什么要选择大公司，可以完全不用考虑小公司</p><h2 id="能学到很多东西"><a href="#能学到很多东西" class="headerlink" title="能学到很多东西"></a>能学到很多东西</h2><p>小公司最大的噱头就是招聘的时候，跟我们说能学到很多东西，能接触很多核心内容，而我们若是去了大公司，终究只能“拧螺丝”</p><p>这句话对追求个人成长的年轻人来说有着致命的诱惑，也是绝大多数应届毕业生不去大公司而选择小公司的理由</p><p>此话虽不假，但终究是噱头，就拿我上面说的，接触多了又什么用呢？只会分散我们的注意力</p><p>并且有深度的东西不会交给我们做，都交给有大公司背景出身，在行业内有着多年经验的高级员工了，到最后我们终究只是了解了一个广度知识罢了</p><p>广度知识重要不重要？重要，但对不足五年工作经验的人来说，知识的深度更重要</p><p>30岁之前拼的就是个人的成长，30岁之后拼的就是行业沉淀，毕竟到了一定的年龄，学习能力以及接受新事物的能力都会随之下降，他们跟我们年轻人拼成长是拼不过的</p><p>所以我们要了解我们自己的核心优势，在这个时候，更要专注自己的个人成长</p><h2 id="能跟着公司一起成长"><a href="#能跟着公司一起成长" class="headerlink" title="能跟着公司一起成长"></a>能跟着公司一起成长</h2><p>还有HR说，随着公司的业务飞速发展和扩张，我们也能跟随公司一起高速成长</p><p>公司业务飞速发展后，系统的架构，项目的设计，以及对技术实现的要求都会越来越高</p><p>这时候又回到前面说的那句话了「专业的事情交给专业的人来做」，毕竟我们被招聘进来时，领导层看来做的只是一个相对简单的东西</p><p>这时候我们虽然是跟着公司的成长一起成长了，但在领导层看来，我们并没有超越项目的要求，换句话说就是，在领导层看来，我们还是第一次接触这种大型项目</p><p>没有人希望自己的项目，被别人拿来练手刷经验值，尤其是小公司，一旦失败，结局可能就是万劫不复</p><p>所以我们不会顺理成章的成为升级后项目的主力，公司会另外招聘有着更丰富经验的老手来进行尝试</p><p>说句扎心的话，大多数人在这种情况下，要么被淘汰掉，要么只能帮着老手做些简单的事情</p><p>那这情况有没有解呢？有解。就是我们之前强调的「才华很重要，但是让别人知道自己的才华更重要」</p><p>我们做事，学习的时候，让领导知道我们的高速成长，项目的更新，优化，不是等到项目压力过大时再想办法解决，而是未雨绸缪，由我们自己主动去推动技术的更新，升级</p><p>但这事情说起来容易，做起来难。所以大多数人在最后的结果都是被淘汰掉了或者被冷落，而不是跟着公司一起高速成长</p><p>当然了，上面描述的情况已经算是非常好了，现实却是90%的创业公司都活不过三年，并且在三年后还保持高速发展的更是少之又少</p><h2 id="对小公司的抉择"><a href="#对小公司的抉择" class="headerlink" title="对小公司的抉择"></a>对小公司的抉择</h2><p>实在是进不去大公司了，那小公司之间该怎么抉择呢？</p><p>大公司也不一定就全是好公司，小公司并不是没有好公司。只是相对来说大企业更为稳定，大多数大企业不会拿一些骚操作来骚员工</p><p>小公司也有优秀的公司。上面说的情况只是大多数小公司的情况</p><p>关于怎么选择可以参考一下我上篇文章<a href="https://mp.weixin.qq.com/s/oAP6C_LmMB6R35ako952Cg" target="_blank" rel="noopener">面试前该关注企业哪方面信息才不会后悔？</a>无非就是从经营业务，发展前景以及企业文化，从中取舍来看是否值得去</p><p>不过说句实在话，按现在行业内这个人员流动情况来看，大多数应聘者拿小公司当跳板，那小公司也就拿应聘者当临时劳动力，希望进来就能有产出，也不会用心培养。这就是一个互相伤害的死循环</p><p>所以要找到真正值得去，并且能长待的小公司并不容易</p><p>再说句扎心的，真正有潜力并且优秀的小公司，对员工的要求并不会比大公司低多少。毕竟同样的能力，小公司开的工资比大公司还要高出不少，毕竟大公司有着其它的附加价值</p><p>所以进不去大厂，优秀的小公司照样也进不去，扎心吧</p><p>最后还是安安心心的互相伤害吧，自我驱动进行学习，努力达到目标要求，这样自然而然就能跳出这个死循环</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>没有人能对我们的未来进行负责，能对自己未来负责的只有我们自己，我在这也只能把自己的一点小经验分享给你们，希望在座的各位不要踩一些不必要的坑</p><p><img src="http://ww1.sinaimg.cn/large/007OROpSgy1g5pbxlmfqbj306008f0t1.jpg" alt></p><h2 id="微信扫码关注公众号「闹闹吃鱼」，每周都有好分享"><a href="#微信扫码关注公众号「闹闹吃鱼」，每周都有好分享" class="headerlink" title="微信扫码关注公众号「闹闹吃鱼」，每周都有好分享"></a>微信扫码关注公众号「闹闹吃鱼」，每周都有好分享</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/007OROpSgy1g5pbwts9dkj30hd0cqdhe.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;马上就金九银十了，想必找工作的人也特别多&lt;/p&gt;
&lt;p&gt;这几天在搜一些市场招聘信息，了解了下市场的
      
    
    </summary>
    
      <category term="面试" scheme="https://AdolphKevin.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="企业信息" scheme="https://AdolphKevin.github.io/tags/%E4%BC%81%E4%B8%9A%E4%BF%A1%E6%81%AF/"/>
    
  </entry>
  
  <entry>
    <title>用Go语言写一个简单的Restful接口</title>
    <link href="https://AdolphKevin.github.io/2019/07/30/%E7%94%A8Go%E8%AF%AD%E8%A8%80%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84Restful%E6%8E%A5%E5%8F%A3/"/>
    <id>https://AdolphKevin.github.io/2019/07/30/用Go语言写一个简单的Restful接口/</id>
    <published>2019-07-29T16:00:00.000Z</published>
    <updated>2019-08-05T18:30:41.732Z</updated>
    
    <content type="html"><![CDATA[<p>今天我们看看用Go语言如何实现Restful规范的接口，过两天再从今天的这个实践出发，去了解理论知识</p><h2 id="Restful-API的思路"><a href="#Restful-API的思路" class="headerlink" title="Restful API的思路"></a>Restful API的思路</h2><h2 id="API的具体实现"><a href="#API的具体实现" class="headerlink" title="API的具体实现"></a>API的具体实现</h2><p>首先安装<code>mux</code>包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/gorilla/mux</span><br></pre></td></tr></table></figure></p><p><code>mux</code>包主要是用于执行HTTP路由的请求和分配</p><p>安装成功后就可以开始进行我们的<code>Restful</code>接口的实现咯</p><p>先说明一下，因为只是实现一个<code>Restful</code>规范的接口用于练习，所以我们所有的代码都是放在主程序入口<code>main.go</code>之中</p><h4 id="实现结构体"><a href="#实现结构体" class="headerlink" title="实现结构体"></a>实现结构体</h4><p>先实现一个结构体，用于存放我们的数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person 人</span></span><br><span class="line"><span class="comment">// 有了omitempty后，如果字段内容为空， 则生成的json中则没有该字段</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">ID      <span class="keyword">string</span>   <span class="string">`json:"id,omitempty"`</span></span><br><span class="line">Name    <span class="keyword">string</span>   <span class="string">`json:"name,omitempty"`</span></span><br><span class="line">Address *Address <span class="string">`json:"address,omitempty"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Address 地址</span></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">City  <span class="keyword">string</span> <span class="string">`json:"city,omitempty"`</span></span><br><span class="line">State <span class="keyword">string</span> <span class="string">`json:"state,omitempty"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体字段标签的<code>omitempty</code>意味着序列化时忽略0值或空值，练习的时候可加可不加，再项目中运用时就全看项目要求了</p><h4 id="API的实现"><a href="#API的实现" class="headerlink" title="API的实现"></a>API的实现</h4><p>结构体定义好后，我们再来写一个<code>API</code>，用于处理用户的请求</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetPerson 获取Person</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetPerson</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取参数</span></span><br><span class="line">params := mux.Vars(req)</span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> people &#123;</span><br><span class="line"><span class="keyword">if</span> item.ID == params[<span class="string">"id"</span>] &#123;</span><br><span class="line">            <span class="comment">// 以json格式将结构体回写</span></span><br><span class="line">json.NewEncoder(w).Encode(item)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有查询到对应ID，返回一个空的结构体</span></span><br><span class="line">json.NewEncoder(w).Encode(&amp;Person&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好啦，定义好一个<code>API</code>后，我们就可以开始写<code>main</code>函数来处理HTTP请求啦</p><p>内容和实现方式都放在注释里啦</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个全局数组，用于存储结构体数据</span></span><br><span class="line"><span class="keyword">var</span> people []Person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 初始化路由</span></span><br><span class="line">router := mux.NewRouter()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向people中添加一些数据</span></span><br><span class="line">people = <span class="built_in">append</span>(people, Person&#123;ID: <span class="string">"1"</span>, Name: <span class="string">"闹闹"</span>, Address: &amp;Address&#123;City: <span class="string">"苏杭"</span>, State: <span class="string">"1"</span>&#125;&#125;)</span><br><span class="line">people = <span class="built_in">append</span>(people, Person&#123;ID: <span class="string">"2"</span>, Name: <span class="string">"闹闹吃鱼"</span>, Address: &amp;Address&#123;City: <span class="string">"地球"</span>, State: <span class="string">"2"</span>&#125;&#125;)</span><br><span class="line">people = <span class="built_in">append</span>(people, Person&#123;ID: <span class="string">"1"</span>, Name: <span class="string">"naonao"</span>, Address: &amp;Address&#123;City: <span class="string">"emmm"</span>, State: <span class="string">"3"</span>&#125;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理并分派路由请求</span></span><br><span class="line">    <span class="comment">// GET请求</span></span><br><span class="line">router.HandleFunc(<span class="string">"/people"</span>, GetPeople).Methods(<span class="string">"GET"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听端口</span></span><br><span class="line">err := http.ListenAndServe(<span class="string">":8888"</span>, router)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天我们看看用Go语言如何实现Restful规范的接口，过两天再从今天的这个实践出发，去了解理论知识&lt;/p&gt;
&lt;h2 id=&quot;Restful-API的思路&quot;&gt;&lt;a href=&quot;#Restful-API的思路&quot; class=&quot;headerlink&quot; title=&quot;Restfu
      
    
    </summary>
    
      <category term="golang" scheme="https://AdolphKevin.github.io/categories/golang/"/>
    
    
      <category term="Restful" scheme="https://AdolphKevin.github.io/tags/Restful/"/>
    
  </entry>
  
  <entry>
    <title>面试前该关注企业哪方面信息才不会后悔？</title>
    <link href="https://AdolphKevin.github.io/2019/07/29/%E9%9D%A2%E8%AF%95%E5%89%8D%E8%AF%A5%E5%85%B3%E6%B3%A8%E5%85%AC%E5%8F%B8%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>https://AdolphKevin.github.io/2019/07/29/面试前该关注公司什么？/</id>
    <published>2019-07-28T16:00:00.000Z</published>
    <updated>2019-07-28T09:44:03.957Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/007OROpSgy1g5fp12w0q8j30ee0bvdmp.jpg" alt></p><p>周一，真的是一周里最想划水的一天</p><p>既然按捺不住了，那就遵从自己的内心召唤，一起摸个鱼吧，带薪摸鱼也是美滋滋的</p><p><img src="http://ww1.sinaimg.cn/large/007OROpSgy1g5fep6ypbfj307d04w751.jpg" alt></p><p>今天聊聊找工作时，接到面试通知后，公司是否值得我们一试的问题</p><p>说到这你可能有些困惑，找工作的时候接到面试电话，咱们一般的反应都是有机会就去试一试，不管过没过，至少涨了点面试经验</p><p>想法是好的，可是现实却很残酷，想必大家这几个月听说了很多程序员被骗去菲律宾压榨的事情</p><p>没工资拿，吃着泡面，出了Bug还要被打，想想都恐怖</p><p>不过我这种打死也不出国的码畜，估计也骗不到我头上来</p><p>虽然国外的骗局能躲过，可国内的却并不是那么的风平浪静，只是相对而言会好不少</p><p>其中最典型的一个事情就是某内培训机构，打着招聘的幌子，骗刚出校门没多久的学生去他们那儿培训</p><p>基本套路就是把你弄去面试，做个面试题，让你上机操作一把，说你这基础不行啊，把你打击一番，然后说去他们那儿参加培训，把咱们唬的一愣一愣的</p><p>他们还有赌狗操作，就是赌面试者不看合同，告诉我们面试已经通过了，先签个合同。接着说这是在岗培训，让我们先签一个在岗培训合同</p><p>有些人正愁找不到工作，突然有公司愿意接纳自己了，就希望这时候给人家留下一个爽快印象，然后闭着眼睛就把合同给签了</p><p>这一签，身上就背上了好几万的贷款了，更多详细的信息可以看我之前投稿出去的文章「<a href="http://mp.weixin.qq.com/s?__biz=MzI5ODM3MjcxNQ==&amp;mid=2247485141&amp;idx=1&amp;sn=2d16d671193cc6fb529009daf6fa3100&amp;chksm=eca79dd1dbd014c7feafb3eaa448ec082885d94bd75a124624c95ffe655e2d4890dff87a28f6&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">二蛋和培训机构斗智斗勇的血泪史</a>」，在这就不多说了</p><p>当然了，有过一两年工作经验之后，基本没有不长眼的培训机狗会打电话到我们手上，我们自己也具备了辨识公司是否是培训机构的能力</p><p>虽然能分辨是不是培训机构，但还没到能不能分辨公司是否正规，是否有足够潜力的能力，而关于这两点，大多数人都是在入职后接触业务后才能发现</p><p>虽然最后能发现，但是这两点我们在入职前甚至是面试前就能调查清楚，入职后再发现，自己不仅浪费了大把的时间，更是浪费了更多的面试机会</p><p>大多数的面试者，都只有被调查的份，却不知道怎么调查公司</p><p>大多数人都只是通过搜索引擎搜索公司的相关信息，然后看相关评论，或者进入公司官网进行查看</p><p>然后在面试的时候被问「你对我们公司了解了多少」时，要么就是哑口无言，要么就是瞎几把扯，或者把人家官网上的介绍照搬过来尬聊下，敷衍了事</p><p>当然了，并不是说不要用搜索引擎，而是要有目的的去搜索信息，搜索引擎只是其中的一个渠道和手段</p><p>今天咱们就简单聊聊面试前的调查准备，关于抉择公司是否值得入职时的调查，之后再抽时间说吧</p><p>不过思路大致上是一样的，只是咱们挖掘的深度不一样，毕竟面试前只要不是去咱们特别特别想去的公司面试，基本上都只是做个简单调查，而特别特别想去的公司，我想很早之前咱们就调查的差不多了</p><h2 id="搜集公司信息渠道"><a href="#搜集公司信息渠道" class="headerlink" title="搜集公司信息渠道"></a>搜集公司信息渠道</h2><p>这也就是今天摸鱼要摸的重点了，毕竟给鸡汤不给汤匙，就是耍流氓了</p><p>「天眼查」跟「企查查」这种收费的就不说了，在这里给你们推荐一款免费的APP「企业预警通」，提供的免费功能已经足够我们使用了</p><p>这玩意是我炒股找研报的时候发现的，没想到查公司也挺好用，今天就分享给你们，有兴趣的可以下载下来玩玩</p><p>这不是专业的提供企业研报软件，就如名字说所，用于查询企业风险的</p><p>我们在面试前主要也就关注公司2个点，「企业信用」以及「司法诉讼」</p><p>毕竟在当下社会，个人失信都变得寸步难行，更何况企业失信，对于失信企业，我们都不用考虑的</p><p>对于那些拖欠工资上了仲裁的，我们也就不必去了，毕竟拖工资这事情，要么就是老板不想发，要么就是想发却发不出来</p><p>第一个原因就不用解释了，跟着这样的老板，别说吃肉了，汤都没咱们的份。第二个原因多半意味着公司的资金链出现了问题，而公司的资金链一旦出了问题，起死回生的概率是微乎其微</p><p>所以该不该去，该不该留，这时候我想在座的各位心里都有数了</p><h2 id="关注企业业务"><a href="#关注企业业务" class="headerlink" title="关注企业业务"></a>关注企业业务</h2><p>我一直都是主张着业务为王，虽然咱们只是写写代码，但是也应该关注业务</p><p>毕竟有业务才会有需求，有需求才会需要我们写代码，技术是为了支持业务更好的发展才能实现价值</p><p>所以一家公司的业务模式赚不赚钱，也决定了我们写代码的能不能赚到钱，不要幻想着连老板都赚不到钱了，手下的员工还能赚到钱。毕竟这样的公司要么已经倒闭了，要么就在申请破产的路上</p><p>把一家公司当成一个产品去看待，把企业经营的业务当作产品提供的功能</p><p>产品提供的功能，解决了什么样的痛点，如果其商业模式我们能看懂，确实有潜在市场，并且产品有着门槛，一般人想入场分羹不容易，那对我们来说，确实就是一家不错的企业了</p><h2 id="关注企业文化"><a href="#关注企业文化" class="headerlink" title="关注企业文化"></a>关注企业文化</h2><p>企业正规，资金流健康，公司业务我们能看懂，并且还能赚钱，确实是一家不错的公司了，但我们不能忽略一个同样重要的事情，那就是企业文化</p><p>一家公司的高层领导人对企业文化肯定是高度认可的，企业文化不仅仅是一个口号，更是象征着整个公司高层为此奋斗的愿景</p><p>企业文化若是能与我们自己的价值观不谋而合，那自然好，可若不合，那我们进去之后也是一种折磨</p><p>企业文化基本上都在企业官网上，或者在招聘信息中都可以看到，关于企业文化，2000字的文章都不够写的，在这就简单提一下</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>其实选公司就是一场投资，我们是有机会成本的，虽然不用让我们掏腰包，对公司进行真金白银的投入，但我们投入的是自己的时间，自己的精力</p><p>千万不要做连自己都看不懂的投资。如果公司所经营的业务自己看不懂，先不提升职加薪，会不会被公司反坑一手都难说</p><p>公司做违法的事情，在职员工也是有连带责任的</p><p>很多东西因为篇幅问题无法细说，就简短的写个大致思路，希望能帮你在找工作时避免一些雷区，节约更多的成本</p><p><img src="http://ww1.sinaimg.cn/large/007OROpSgy1g5feq7f3xbj30am09zgm6.jpg" alt></p><h2 id="微信扫码关注公众号「闹闹吃鱼」，每周都有好分享"><a href="#微信扫码关注公众号「闹闹吃鱼」，每周都有好分享" class="headerlink" title="微信扫码关注公众号「闹闹吃鱼」，每周都有好分享"></a>微信扫码关注公众号「闹闹吃鱼」，每周都有好分享</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/007OROpSgy1g5fp12w0q8j30ee0bvdmp.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;周一，真的是一周里最想划水的一天&lt;/p&gt;
&lt;p&gt;既然按捺不住了，那就遵从自己的内心召唤，一起摸个鱼
      
    
    </summary>
    
      <category term="面试" scheme="https://AdolphKevin.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="企业信息" scheme="https://AdolphKevin.github.io/tags/%E4%BC%81%E4%B8%9A%E4%BF%A1%E6%81%AF/"/>
    
  </entry>
  
  <entry>
    <title>golang的反射机制与实践（下）</title>
    <link href="https://AdolphKevin.github.io/2019/06/13/golang%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>https://AdolphKevin.github.io/2019/06/13/golang的反射机制与实践（下）/</id>
    <published>2019-06-12T23:07:33.000Z</published>
    <updated>2019-08-05T18:14:09.053Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/15072499-8cbc0a3af2305f9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>上篇说了下反射该怎么用，现在我们来看一看使用反射的实际情况，深入理解一下</p><p>这篇因为是实践篇，所以有大量的代码示例来进行演示，<strong>因为只是演示反射的使用，所以对一些复杂的错误机制没做处理</strong></p><p>反射本身并不难，看懂了上一章反射到底是干嘛用的，什么时候用，这一章其实非常好懂</p><p><strong>说到底就是将<code>reflect</code>包提供给我们的方法，进行一些组合使用罢了</strong>，说土一点就是调用下API</p><p>没看上篇的可以先看看<a href>golang的反射与实践（上）</a></p><h2 id="反射的实践操作"><a href="#反射的实践操作" class="headerlink" title="反射的实践操作"></a>反射的实践操作</h2><p>好了，咱们开始进行实践</p><p>先把我们的准备工作做好，先定义一个<code>Struct</code>，再给这个结构体加上一些方法<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Employee 员工</span></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span> <span class="string">`json:"emp_name"`</span></span><br><span class="line">Age  <span class="keyword">int</span>    <span class="string">`json:"emp_age"`</span></span><br><span class="line">Sex  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetSum 返回两数之和</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span> <span class="title">GetSum</span><span class="params">(n1, n2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> n1 + n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set 接受值，给结构体e赋值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span> <span class="title">Set</span><span class="params">(name <span class="keyword">string</span>, age, sex <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">e.Name = name</span><br><span class="line">e.Age = age</span><br><span class="line">e.Sex = sex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print 打印结构体*Employee </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Employee)</span> <span class="title">Print</span><span class="params">()</span></span> &#123;</span><br><span class="line">log.Print(<span class="string">"======Start======"</span>)</span><br><span class="line">log.Print(e)</span><br><span class="line">log.Print(<span class="string">"======End======"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>随便给这个结构体写了几个方法，我们主要是看，我们如何使用反射在运行时对变量进行一个操作</p><h2 id="使用反射来遍历结构体的字段值，并获取结构体的tag标签"><a href="#使用反射来遍历结构体的字段值，并获取结构体的tag标签" class="headerlink" title="使用反射来遍历结构体的字段值，并获取结构体的tag标签"></a>使用反射来遍历结构体的字段值，并获取结构体的tag标签</h2><p>先来看个常规用法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetStruct 获取结构体的字段及tag</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetStruct</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">rType := reflect.TypeOf(i)</span><br><span class="line">rVal := reflect.ValueOf(i)</span><br><span class="line"></span><br><span class="line">kd := rVal.Kind()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是传进来的是指针类型</span></span><br><span class="line"><span class="comment">// 则获取指针值</span></span><br><span class="line"><span class="keyword">if</span> kd == reflect.Ptr &#123;</span><br><span class="line">rType = rType.Elem()</span><br><span class="line">rVal = rVal.Elem()</span><br><span class="line">kd = rVal.Kind()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> kd != reflect.Struct &#123;</span><br><span class="line">log.Panicf(<span class="string">"Kind is %v not struct "</span>, kd)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取结构体的字段数</span></span><br><span class="line">sNum := rVal.NumField()</span><br><span class="line">log.Printf(<span class="string">"Struct has %v fields "</span>, sNum)</span><br><span class="line"><span class="comment">// 遍历结构体的所有字段</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; sNum; i++ &#123;</span><br><span class="line">log.Printf(<span class="string">"Field %d value is %v"</span>, i, rVal.Field(i))</span><br><span class="line"><span class="comment">// 获取Struct的tag，使用Type类型获取</span></span><br><span class="line">tag := rType.Field(i).Tag.Get(<span class="string">"json"</span>)</span><br><span class="line"><span class="keyword">if</span> tag == <span class="string">""</span> &#123;</span><br><span class="line">log.Printf(<span class="string">"Field %d hasn't tag  %v "</span>, i, tag)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">"Field %d tag is %v "</span>, i, tag)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定义一个方法<code>GetStruct(i interface{})</code>，因为入参是<code>interface{}</code>类型，所以这个方法可以接收并处理所有的数据类型。这就是反射的牛逼之处了</p><p>遗憾的是，反射的性能比较低。后面咱们对性能进行分析时再拿出来聊聊</p><p>测试用例如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestGetStruct</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">emp := &amp;Employee&#123;&#125;</span><br><span class="line">emp.Set(<span class="string">"闹闹"</span>, <span class="number">99</span>, <span class="number">0</span>)</span><br><span class="line">GetStruct(emp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下图所示</p><p><img src="http://ww1.sinaimg.cn/large/007OROpSgy1g3v341z04cj30c905ujr6.jpg" alt></p><p>这个函数接受的参数是<code>interface</code>，也就是说，通过这个函数，不管入参传递了什么样的结构体，我们可以知道这个结构体有什么标签，有几个方法</p><p>获取<code>tag</code>标签的用处就是对我们的结构体进行序列化时使用，将结构体的字段名变成我们需要的别名</p><p>想深入了解的童鞋，可以参考下<code>encoding/json</code>包的使用方式</p><h2 id="获取并调用结构体的方法"><a href="#获取并调用结构体的方法" class="headerlink" title="获取并调用结构体的方法"></a>获取并调用结构体的方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CallMethod 调用结构体方法</span></span><br><span class="line"><span class="comment">// i : 传入的struct</span></span><br><span class="line"><span class="comment">// methodByName : 调用结构体的方法名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CallMethod</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;, methodByName <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">rVal := reflect.ValueOf(i)</span><br><span class="line">rType := reflect.TypeOf(i)</span><br><span class="line">log.Printf(<span class="string">"Type is %v Kind is %v"</span>, rType, rType.Kind())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取结构体有多少个方法</span></span><br><span class="line">numOfMethod := rVal.NumMethod()</span><br><span class="line">log.Printf(<span class="string">"Struct has %d method"</span>, numOfMethod)</span><br><span class="line"><span class="comment">// 声明Value数组</span></span><br><span class="line"><span class="keyword">var</span> params []reflect.Value</span><br><span class="line"><span class="comment">// 声明一个Value类型，用于接收方法</span></span><br><span class="line"><span class="keyword">var</span> method reflect.Value</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> methodByName == <span class="string">"GetSum"</span> &#123;</span><br><span class="line"><span class="comment">// 调用方法时的参数</span></span><br><span class="line">params = <span class="built_in">append</span>(params, reflect.ValueOf(<span class="number">10</span>))</span><br><span class="line">params = <span class="built_in">append</span>(params, reflect.ValueOf(<span class="number">88</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> methodByName == <span class="string">"Set"</span> &#123;</span><br><span class="line"><span class="comment">// 调用方法时的参数</span></span><br><span class="line">params = <span class="built_in">append</span>(params, reflect.ValueOf(<span class="string">"闹闹吃鱼"</span>))</span><br><span class="line">params = <span class="built_in">append</span>(params, reflect.ValueOf(<span class="number">18</span>))</span><br><span class="line">params = <span class="built_in">append</span>(params, reflect.ValueOf(<span class="number">0</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取方法</span></span><br><span class="line">method = rVal.MethodByName(methodByName)</span><br><span class="line"><span class="keyword">if</span> !method.IsValid() &#123;</span><br><span class="line"><span class="comment">// 如果结构体不存在此方法，输出Panic</span></span><br><span class="line">log.Panic(<span class="string">"Method is invalid"</span>)</span><br><span class="line">&#125;</span><br><span class="line">result := method.Call(params)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(result) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 如果函数存在返回值，则打印第一条</span></span><br><span class="line">log.Println(<span class="string">"Call result is "</span>, result[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里值得注意一点的就是，我们通过反射的<code>Call</code>去调用函数，传入的参数的类型是<code>reflect.Value</code>类型，并不是我们定义函数时的<code>int</code>类型</p><p>所以在调用函数时传入的参数需要进行一个类型转换</p><p>给你们附上测试用例，你们可以自己调试跑跑，会发现，不管你传的结构体的字段是什么，我都进行统一处理了<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCallMethod</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">emp := &amp;Employee&#123;&#125;</span><br><span class="line">emp.Set(<span class="string">"闹闹"</span>, <span class="number">99</span>, <span class="number">0</span>)</span><br><span class="line">emp.Print()</span><br><span class="line">CallMethod(emp, <span class="string">"Set"</span>)</span><br><span class="line">emp.Print()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="修改字段值"><a href="#修改字段值" class="headerlink" title="修改字段值"></a>修改字段值</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ModifyField 修改字段值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ModifyField</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;, filedName <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">rVal := reflect.ValueOf(i)</span><br><span class="line">filed := rVal.Elem().FieldByName(filedName)</span><br><span class="line"><span class="keyword">if</span> !filed.IsValid() &#123;</span><br><span class="line">log.Panic(<span class="string">"filedName is invalid"</span>)</span><br><span class="line">&#125;</span><br><span class="line">filed.SetString(<span class="string">"闹闹"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行时修改结构体的字段，主要就是做到一个通用性，比如上述的例子，不管是什么结构体</p><p>依然附上测试用例<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestModifyField</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">emp := &amp;Employee&#123;&#125;</span><br><span class="line">ModifyField(emp, <span class="string">"Name"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不管传入的结构体是什么，只要包含了<code>filedName</code>（我们指定的字段名），我们就可以对其进行值的更改</p><p>假如我们有100个结构体，需要对<code>name</code>字段进行修改，通过反射的机制，我们代码的耦合度将大大的降低</p><h2 id="定义适配器，用作统一处理接口"><a href="#定义适配器，用作统一处理接口" class="headerlink" title="定义适配器，用作统一处理接口"></a>定义适配器，用作统一处理接口</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bridge 适配器</span></span><br><span class="line"><span class="comment">// 可以实现调用任意函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bridge</span><span class="params">(call <span class="keyword">interface</span>&#123;&#125;, args ...<span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">function reflect.Value</span><br><span class="line">inValue  []reflect.Value</span><br><span class="line">)</span><br><span class="line">n := <span class="built_in">len</span>(args)</span><br><span class="line"><span class="comment">// 将参数转换为Value类型</span></span><br><span class="line">inValue = <span class="built_in">make</span>([]reflect.Value, n)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">inValue[i] = reflect.ValueOf(args[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获得函数的Value类型</span></span><br><span class="line">function = reflect.ValueOf(call)</span><br><span class="line"><span class="comment">// 传参，调用函数</span></span><br><span class="line">function.Call(inValue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写了个测试用例，函数是我们在调用<code>Bridge</code>前就已经定义好了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestBridge</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">call1 := <span class="function"><span class="keyword">func</span><span class="params">(v1, v2 <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">log.Println(v1, v2)</span><br><span class="line">&#125;</span><br><span class="line">call2 := <span class="function"><span class="keyword">func</span><span class="params">(v1, v2 <span class="keyword">int</span>, str <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">log.Println(v1, v2, str)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bridge(call1, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">Bridge(call2, <span class="number">2</span>, <span class="number">3</span>, <span class="string">"callTest"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个函数是不同的函数，但是都可以通过<code>Bridge</code>进行执行</p><p>适配器有什么用呢？如果不知道的童鞋，可以去看看设计模式「适配器模式」</p><p>因为本篇幅只是说如何在实战中应用反射，所以这里就不讲解设计模式了</p><h2 id="使用反射创建，并操作结构体"><a href="#使用反射创建，并操作结构体" class="headerlink" title="使用反射创建，并操作结构体"></a>使用反射创建，并操作结构体</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CreateStruct 使用反射创建结构体</span></span><br><span class="line"><span class="comment">// 并给结构体赋值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateStruct</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> *<span class="title">Employee</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">structType  reflect.Type</span><br><span class="line">structValue reflect.Value</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 获取传入结构体指向的Type类型</span></span><br><span class="line">structType = reflect.TypeOf(i).Elem()</span><br><span class="line"><span class="comment">// 创建一个结构体</span></span><br><span class="line"><span class="comment">// structValue持有一个指向类型为Type的新申请的指针</span></span><br><span class="line">structValue = reflect.New(structType)</span><br><span class="line"><span class="comment">// 转换成我们要创建的结构体</span></span><br><span class="line">modle := structValue.Interface().(*Employee)</span><br><span class="line"><span class="comment">// 取得structValue指向的值</span></span><br><span class="line">structValue = structValue.Elem()</span><br><span class="line"><span class="comment">// 给结构体赋值</span></span><br><span class="line">structValue.FieldByName(<span class="string">"Name"</span>).SetString(<span class="string">"闹闹吃鱼"</span>)</span><br><span class="line">structValue.FieldByName(<span class="string">"Age"</span>).SetInt(<span class="number">100</span>)</span><br><span class="line"><span class="keyword">return</span> modle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式就看看测试用例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestCreateStruct</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">emp := &amp;Employee&#123;</span><br><span class="line">Name: <span class="string">"NaoNao"</span>,</span><br><span class="line">Age:  <span class="number">18</span>,</span><br><span class="line">Sex:  <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line">emp.Print()<span class="comment">// &amp;&#123;NaoNao 18 1&#125;</span></span><br><span class="line">newEmp := CreateStruct(emp)</span><br><span class="line">newEmp.Print()<span class="comment">// &amp;&#123;闹闹吃鱼 100 0&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能你会问，<code>CreateStruct</code>的入参不是<code>interface{}</code>吗？可为什么我传一个任意的结构体，却要给返回一个指定的结构体呢？就不能我传什么结构体进去，就返回什么结构体出来吗？</p><p>理想总是丰满的，现实却是非常骨感，虽然我们反射的方法实现，都是将入参写为<code>interface{}</code>，但<strong>使用反射并不是意味着我们一定就写了一个万能的程序</strong></p><p>还记得上一篇提到的，<code>变量</code>与<code>reflect.Value</code>之间该如何转换吗？</p><p>咱们再复习一下：<code>变量&lt;------&gt;interface{}&lt;------&gt;reflect.Value</code></p><p>我们<strong>不管是把<code>Value</code>转为结构体，还是转为基本类型，我们都需要在编译前确定转换后的类型</strong></p><p>换句话说，只要我们在运行时牵扯到类型的转换，我们都需要各种<code>if</code>来判断是否能转换成我们需要的类型</p><p>本文以大量的代码实现来阐述反射该怎么用，说实话，挺无聊的</p><p>写这篇文章的目的就是让你拿电脑上去编译跑跑，或者什么时候想到要用反射了，可以拿出来瞅瞅，看看什么地方需要用到反射，反射又可以干什么</p><p><img src="http://ww1.sinaimg.cn/large/007OROpSgy1g5pbxlmfqbj306008f0t1.jpg" alt></p><h2 id="微信扫码关注公众号「闹闹吃鱼」，每周都有好分享"><a href="#微信扫码关注公众号「闹闹吃鱼」，每周都有好分享" class="headerlink" title="微信扫码关注公众号「闹闹吃鱼」，每周都有好分享"></a>微信扫码关注公众号「闹闹吃鱼」，每周都有好分享</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/15072499-8cbc0a3af2305f9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240
      
    
    </summary>
    
      <category term="golang" scheme="https://AdolphKevin.github.io/categories/golang/"/>
    
    
      <category term="反射" scheme="https://AdolphKevin.github.io/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>golang的反射机制与实践（上）</title>
    <link href="https://AdolphKevin.github.io/2019/06/09/golang%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%AE%9E%E8%B7%B5%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>https://AdolphKevin.github.io/2019/06/09/golang的反射机制与实践（上）/</id>
    <published>2019-06-08T19:16:43.000Z</published>
    <updated>2019-08-05T18:14:06.490Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/007OROpSgy1g3xzl0lw59j30hn0dgdl9.jpg" alt></p><p>反射机制是一个很重要的内容，当我们写框架的时候，要想要松耦合，高复用，那么就有很多地方都需要用到反射，可谓是中高级程序员必须掌握的知识点</p><p>很多后台语言都有反射机制，但它们的使用原理大多都是一样的</p><p>各语言不同的地方，大致就是代码实现方式不一致罢了</p><p><strong>其根本，都是从变量得到反射对象，再由反射对象去操作原变量</strong></p><p>好了，步入正题</p><h2 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h2><p>我就用一句话来概括吧</p><p><strong>使用反射，可以让我们在程序运行时对任意类型的对象进行操作</strong></p><p>注意操作这两个字，操作是指：可以获取对象的信息、改变对象的值、调用对象的方法、甚至是创建一个对象</p><p>说到这你可能有点困惑，我们在编写代码的时候不就已经把该实例化的象进行了实例化，该调用的方法都调用了嘛？为什么写程序的时候不调用方法，偏要在运行时去进行这些操作？</p><p>其实问题就在这里，如果我们在写程序的时候，一切的对象与方法都能够确定了，那还要反射做什么？</p><p>正是因为我们在写程序的时候，要想写一些“万能程序”，用于降低代码的耦合度，所以我们才需要反射，用于处理一些未知的对象</p><p>想想，当我们写一个方法，不管别人往我们这个方法内传入什么样的参数，最后我们的函数都能给别人所需要的内容。是不是感觉很牛逼？</p><h2 id="反射的使用原理"><a href="#反射的使用原理" class="headerlink" title="反射的使用原理"></a>反射的使用原理</h2><p>我这里主要说使用反射的原理，并不是刨析反射的底层原理，有兴趣想要探索原理的读者大人，可以去看看go的reflect包源码</p><p>先给你们上个图，看懂这个关系图，后面的文字基本也就可以不看了</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/12/16b48b7578b23a34?w=614&amp;h=415&amp;f=jpeg&amp;s=97836" alt></p><p>没看懂没关系，稍微解释就能明白~~</p><p>我们定义的一个变量，不管是基本类型<code>int</code>，还是一个结构体<code>Employee</code>，我们都可以通过<code>reflect.TypeOf()</code>获取他的反射类型<code>Type</code>，也可以通过<code>reflect.ValueOf()</code>去获取他的反射值<code>Value</code></p><p><strong>我们学习反射，其实就是学习如何使用原变量，去取得<code>reflect.Type</code>或者<code>reflect.Value</code>这种反射对象；再使用这个反射对象<code>Type</code>以及<code>Value</code>，反过来对原变量进行操作</strong></p><p>弄明白了这个道理，那一切都将变得简单</p><p>剩下的，我们只是需要去学习<code>reflect</code>包中提供的方法。当我们需要要怎么操作变量，就使用其提供的对应方法即可</p><h2 id="反射的注意事项与细节"><a href="#反射的注意事项与细节" class="headerlink" title="反射的注意事项与细节"></a>反射的注意事项与细节</h2><h4 id="Type与Kind的区别是什么？"><a href="#Type与Kind的区别是什么？" class="headerlink" title="Type与Kind的区别是什么？"></a><code>Type</code>与<code>Kind</code>的区别是什么？</h4><p><code>Type</code>是类型，<code>Kind</code>是类别，听起来有点绕，<strong>他们之间的关系为<code>Type</code>是<code>Kind</code>的子集</strong></p><p>如果变量是基本类型，那么<code>Type</code>与<code>Kind</code>得到的结果是一致的，比如变量为<code>int</code>类型，<code>Type</code>与<code>Kind</code>的值相等，都为<code>int</code></p><p>但当变量为结构体时，<code>Type</code>与<code>Kind</code>的值就不一样了</p><p>我们来看个实际案例<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> emp Employee</span><br><span class="line">emp = Employee&#123;</span><br><span class="line">Name: <span class="string">"naonao"</span>,</span><br><span class="line">Age:  <span class="number">99</span>,</span><br><span class="line">&#125;</span><br><span class="line">rVal := reflect.ValueOf(emp)</span><br><span class="line">log.Printf(<span class="string">"Kind is %v ,Type is %v"</span>,</span><br><span class="line">rVal.Kind(),</span><br><span class="line">rVal.Type())</span><br><span class="line"><span class="comment">// Kind is struct ,Type is main.Employee</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，<code>Kind</code>的值是<code>struct</code>,而<code>Type</code>的值是<code>包名.Employee</code></p><h4 id="反射如何在变量与reflect-Value之间切换？"><a href="#反射如何在变量与reflect-Value之间切换？" class="headerlink" title="反射如何在变量与reflect.Value之间切换？"></a>反射如何在变量与<code>reflect.Value</code>之间切换？</h4><p>变量可以转换成<code>interface{}</code>之后，再转换成<code>reflect.Value</code>类型，既然空接口可以转换成<code>Value</code>类型，那么自然也可以反过来转换成变量</p><p>用个表达式来表示，就如下所示</p><blockquote><p>变量<----->interface{}<----->reflect.Value</-----></-----></p></blockquote><p>利用空接口来进行中转，这样<code>变量</code>与<code>Value</code>之间就可以实现互相转换了</p><p>下面我们再说如何用代码实现转换</p><h4 id="如何使用反射获取变量本身的值？"><a href="#如何使用反射获取变量本身的值？" class="headerlink" title="如何使用反射获取变量本身的值？"></a>如何使用反射获取变量本身的值？</h4><p>这里我们要注意一下，<code>reflect.ValueOf()</code>得到的值是<code>reflect.Value</code>类型，并不是变量本身的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1</span></span><br><span class="line">rVal := reflect.ValueOf(num)</span><br><span class="line">log.Printf(<span class="string">"num is %v"</span>, num + rVal)</span><br></pre></td></tr></table></figure><p>这段代码会报错<code>invalid operation: num + rVal (mismatched types int and reflect.Value)</code></p><p>很明显，<code>rVal</code>是属于<code>reflect.Value</code>类型，不能与<code>int</code>类型相加</p><p>那怎样才能获得它本身的值呢？</p><p><strong>如果是基本类型</strong>，比如<code>var num int</code>,那么使用<code>reflect</code>包里提供的转换方法即可<code>reflect.ValueOf(num).Int()</code></p><p>或者是<code>float</code>，那就调用<code>reflect.ValueOf(num).float()</code>，如果是其它的基本类型，需要的时候去文档里面找找即可</p><p>但<strong>如果是我们自己定义的结构体</strong>，因为<code>reflect</code>包无法确定我们自己定义了什么结构体，所以本身并不会带有结构体转换的方法，那么我们只能<strong>通过类型断言来进行转换</strong></p><p><strong>也就是上面说的，利用空接口进行中转，再利用断言进行类型转换</strong>，可以看如下代码示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Employee 员工</span></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">emp := &amp;Employee&#123;</span><br><span class="line">Name: <span class="string">"naonao"</span>,</span><br><span class="line">Age:  <span class="number">99</span>,</span><br><span class="line">&#125;</span><br><span class="line">reflectPrint(emp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflectPrint</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">rVal := reflect.ValueOf(v)   <span class="comment">// 获取reflect.Value</span></span><br><span class="line">iV := rVal.Interface()       <span class="comment">// 利用空接口进行中转</span></span><br><span class="line">empVal, ok := iV.(*Employee) <span class="comment">// 利用断言转换</span></span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line"><span class="comment">// 如果成功转换则打印结构体</span></span><br><span class="line">log.Print(empVal)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我只是进行了一个简单的判断，如果想要进行完整的判断，还是需要借助<code>swith</code>语句，下篇会提到。也可以参照<code>reflect</code>包的单元测试文件</p><h4 id="通过反射来修改变量"><a href="#通过反射来修改变量" class="headerlink" title="通过反射来修改变量"></a>通过反射来修改变量</h4><p>先来看看代码如何实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">1</span></span><br><span class="line">modifyValue(&amp;num)<span class="comment">// 传递地址</span></span><br><span class="line">log.Printf(<span class="string">"num is %v"</span>, num)<span class="comment">// num is 20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyValue</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">rVal := reflect.ValueOf(i)</span><br><span class="line">rVal.Elem().SetInt(<span class="number">20</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>细心的你肯定发现了一点异常，函数接收的参数不再是值了，而是接受了一个指针地址</p><p>改变值的时候，先调用了<code>Elem()</code>方法，再进行了一个<code>SetInt()</code>的操作</p><p>为什么直接传值不行呢？<strong>因为<code>reflect</code>包中提供的所有修改变量值的方法，都是对指针进行的操作</strong></p><p>那为什么还要先使用<code>Elem()</code>呢？因为<code>Elem()</code>的作用，就是取得指针地址所对应的值，取到值了，我们才能对值进行修改</p><p>总不可能连值都没拿到手，就想着去改值吧？</p><h4 id="如何理解reflect-Value-Elem"><a href="#如何理解reflect-Value-Elem" class="headerlink" title="如何理解reflect.Value.Elem()"></a>如何理解reflect.Value.Elem()</h4><p>关于<code>Elem()</code>的使用可以简单的理解为<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num := <span class="number">1</span></span><br><span class="line">prt *<span class="keyword">int</span> := &amp;num <span class="comment">// 获取num的指针地址</span></span><br><span class="line">num2 := *ptr <span class="comment">// 从指针处取值</span></span><br></pre></td></tr></table></figure></p><p>因为我们传递了一个地址，所以我们要先拿到这个地址的指针，再通过指针去取得所对应的值</p><p><code>reflect</code>包底层实现就是基于这个原理，不过它的底层代码加了较多的判断，用来保证稳定性  </p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>这篇先说些基础概念，下篇我们再从实践出发，看看在什么地方需要使用反射，又该如何使用<code>reflect</code>包提供的方法去实现</p><p><img src="http://ww1.sinaimg.cn/large/007OROpSgy1g5pbxlmfqbj306008f0t1.jpg" alt></p><h2 id="微信扫码关注公众号「闹闹吃鱼」，每周都有好分享"><a href="#微信扫码关注公众号「闹闹吃鱼」，每周都有好分享" class="headerlink" title="微信扫码关注公众号「闹闹吃鱼」，每周都有好分享"></a>微信扫码关注公众号「闹闹吃鱼」，每周都有好分享</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/007OROpSgy1g3xzl0lw59j30hn0dgdl9.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;反射机制是一个很重要的内容，当我们写框架的时候，要想要松耦合，高复用，那么就有很多地方都需要用到反
      
    
    </summary>
    
      <category term="golang" scheme="https://AdolphKevin.github.io/categories/golang/"/>
    
    
      <category term="反射" scheme="https://AdolphKevin.github.io/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>彻底弄懂二分查找法，明确边界的意义</title>
    <link href="https://AdolphKevin.github.io/2019/06/02/%E5%A6%82%E4%BD%95%E6%89%8D%E8%83%BD%E5%86%99%E5%87%BA%E6%AD%A3%E7%A1%AE%E7%9A%84%E7%A8%8B%E5%BA%8F%EF%BC%9F/"/>
    <id>https://AdolphKevin.github.io/2019/06/02/如何才能写出正确的程序？/</id>
    <published>2019-06-02T11:45:39.911Z</published>
    <updated>2019-06-02T11:56:19.711Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/007OROpSgy1g3n1tzs5ytj30gf0cvjvr.jpg" alt></p><p>平时我们写程序的时候，总是莫名其妙的出现Bug，一鼓作气的写完一个接口后，经常被队友喷「你怎么一回事？结果与预期不一致啊」</p><p>老脸一红，然后一个人藏在角落调试半天，才发现原来是某一个边界条件没处理好，导致Bug重重，今天我们从二分查找算法，来聊聊如何写出正确的程序</p><p>像我们熟知的二分查找算法，在1946年就被提出来了，但是到了1962年才出现了完全没有Bug的二分查找法</p><p>二分查找法的思想并不复杂，我们很多人张口就能来，但是为什么间隔了辣么多年，才诞生完全没有Bug的二分查找算法呢？</p><p>因为学习一个算法的思想是很简单的，但是让思想落地，写出完全没有Bug的二分查找，却并不是一件容易的事情</p><p>二分查找算法，难就难在边界条件的处理上，我们经常写出Bug，往往也是出现在边界条件没处理好而导致</p><p><strong>所以我们在写程序时，首先就需要明确的边界的意义，在程序内部的实现时，就是要不断的维护这个边界的意义</strong></p><p>二分查找法的思想在这简单复述一下</p><p>1.在一个有序的数组中，查询一个目标值target，</p><p>2.如果目标值target 比数组的中间值要大，那么我们就往数组中间值后面的范围内去查询</p><p>3.如果目标值target 比数组的中间值要小，我们就往数组中间值前面的范围内查询</p><p>4.如此往复的执行2，3步，直到查询到目标值target 等于其数组范围内的某一个值，然后返回其值对应的索引位置，又或者数组中压根就没有我们想要找的目标值target</p><p>好了，说完了算法的思想，我们就来动手实践一下把。在这里我就用Go语言来实现了，给你们宣传了一个多月让你们学Go语言，还给你们找了那么多学习资料，有从小白到中高级的Go语言视频，也有从小白到大牛的书籍资料。你们要现在一点都没看，那可就枉费我一片苦心了</p><p>想学Golang，但还没有头绪的童鞋，看完文章后直接在公众号后台回复「Go」，即可领取全部学习资源，别忘了回来点个在看啊</p><h2 id="把算法思想落地"><a href="#把算法思想落地" class="headerlink" title="把算法思想落地"></a>把算法思想落地</h2><p>我们先定义一个二分查找的函数<code>MyBinarySearch</code>，之所以叫这名字-，-是因为Go有个<code>binary</code>包，里面有叫<code>BinarySearch</code>的函数，咱们需要跟它区分开来，否则编译器会提示我们在瞎搞（仿佛在跟我说：你是不是傻，有现成的不用，偏要自己搞）<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyBinarySearch</span><span class="params">(arr []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="params">(middle <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们传入一个数组，以及一个要查询的目标值target，如果target 存在于数组中，我们则返回它对应的索引位置</p><p>二分查找，容易出问题的地方就是边界问题，那咱们先定义先设定一个边界，我们需要在边界范围内去查询</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 明确边界的意义，在 [left,right] 中寻找target</span></span><br><span class="line">left, right := <span class="number">0</span>, <span class="built_in">len</span>(arr)<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>我们要铭记，我们在程序中，每一个变量都是有意义的，我们需要明确每一个变量的意义，我们的查询范围，就是在<code>[left,right]</code>中去查询目标值target ，看清楚了，我在这定义的是一个闭区间，也就包含了left 和right 本身所在的位置</p><p>明确边界变量的意义后，我们在后面的查找过程中，还需要不断的维护这个意义</p><p>我们来循环判断，边界是否有意义，如果这个边界的范围区间包含了有效的整数，则代表这个边界是有意义的，所以当边界存在意义时，我们循环判断此时的中间值是否等于目标值target<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line"> <span class="comment">// 在 [left,right] 中寻找target</span></span><br><span class="line">middle = (left + right) / <span class="number">2</span> <span class="comment">// 中间值的索引位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这可能有人不解，为什么要用<code>&lt;=</code>呢？，比如闭区间[8,8] ，那么这个区间依然是有意义的，因为有一个整数8 ，如果去掉<code>=</code>，那就变成了[8,8)，而此时这个区间范围内，是没任何整数的</p><p>现在我们就需要来判断，目标值target 于现在查询范围内中间值的关系，看它是等于，还是小于又或者是大于中间值</p><p>如果相等，那就好办了，这不就是我们要找的嘛~直接返回中间值的索引位置就好了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> arr[middle] == target &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那如果不满足，我们就只好再来判断，目标值是小于中间值还是大于中间值了</p><p>如果目标值target 小于中间值，那么我们就需要缩小查询的区间范围了</p><p>这个时候，我们查询范围就发生了改变，右侧要范围要缩短到中间值的位置，用Code来表达，就是<code>right = middle - 1</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> target &lt; arr[middle] &#123;</span><br><span class="line"><span class="comment">// 如果target &lt; 中间值 则代表我们要在左边区间查找</span></span><br><span class="line">right = middle - <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能会问，为什么要<code>-1</code>呢？因为我们已经明确知道<code>target &lt; arr[middle]</code>，也就是<code>middle</code>所在的位置，不可能是我们要找的位置，所以我们就需要再往左侧移动一位</p><p>说到现在，我想你现在已经彻底弄懂了<code>left</code>与<code>right</code>所代表的含义，那么当<code>target &gt; arr[middle]</code>时，我们的<code>right</code>自然也要在<code>middle</code>的位置上往右移动一位</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> target &gt; arr[middle] &#123;</span><br><span class="line"><span class="comment">// 如果target &gt; 中间值，则代表我们要在右边区间查找</span></span><br><span class="line">left = middle + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的Code全部拼凑起来，就是如下所示，如果当目标值不在数组中时，我们就返回 -1 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyBinarySearch 二分查找法，在有序数组中查询目标元素target，并返回元素对应的索引值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MyBinarySearch</span><span class="params">(arr []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="params">(middle <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">left, right := <span class="number">0</span>, <span class="built_in">len</span>(arr)<span class="number">-1</span> <span class="comment">// 明确边界的意义，在[left,right]中寻找target</span></span><br><span class="line"><span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">middle = (left + right) / <span class="number">2</span></span><br><span class="line"><span class="comment">// 当left &gt; right 时，意味着边界不存在，则代表数组中没有目标值target</span></span><br><span class="line"><span class="comment">// 所以当left &lt;= right 时，我们就遍历数组</span></span><br><span class="line"><span class="keyword">if</span> arr[middle] == target &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> target &lt; arr[middle] &#123;</span><br><span class="line"><span class="comment">// 如果target &lt; 中间值 则代表我们要在左边区间查找</span></span><br><span class="line">right = middle - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> target &gt; arr[middle] &#123;</span><br><span class="line"><span class="comment">// 如果target &gt; 中间值，则代表我们要在右边区间查找</span></span><br><span class="line">left = middle + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我还是简单说下Go语言的函数语法吧，因为我在定义函数的时候，就写明了返回值的变量名<code>middle</code>，给返回值声明了变量名后，执行函数时会给返回值的变量初始化为0值，<code>return</code>返回值也会自动指定对应的变量名</p><p>所以我在函数中没有定义<code>middle</code>以及把<code>return middle</code>直接写成了<code>return</code></p><h2 id="循环不变量"><a href="#循环不变量" class="headerlink" title="循环不变量"></a>循环不变量</h2><p>我猜很多人都是第一次听说这个专业术语，其实我上面已经多次强调这个术语所代表的含义</p><p>现在再刻意解释一下，仔细看完上面的内容的你，现在我一说，你肯定就能懂</p><p>我们在上面的二分查找中，一直在循环<code>left &lt;= right</code>，这就是循环，当<code>left &lt;= right</code>时，我们的循环不会终止</p><p>而不变量是什么呢？<code>left</code>以及<code>right</code>不都是变量么？你怎么说它的不变量呢？</p><p><code>left</code>以及<code>right</code>的值虽然一直都是在改变的，但是它们所代表的含义却是一直都没有改变过，因为我们寻找的永远都是在<code>[left,right]</code>这个闭区间中寻找我们的目标值</p><p>程序中<code>left</code>以及<code>right</code>的变化，也只是在不断缩小这个闭区间的范围，<strong>并没有改变其声明时所代表的含义</strong>，注意我说的，是没有改变<strong>声明时</strong>的含义</p><p>所以要想写出正确的程序，在声明每一个变量时，我们都需要明确其含义，变量在改变时，我们只能改变其数值，而不能改变其变量所代表的意义</p><p>一旦声明其变量的意义，后面的程序都是在维护其意义。就像我们每一个人一生下来就有意义，而我们人生的经历，都是在为了完成人生意义而必须所拥有的铺垫</p><p>之所以我们的Bug越写越多，多半是因为对变量的含义理解的不透彻，并且经常声明一些无意义的变量所导致（可能你认为有些变量并不是无意义的变量，但事实多半如此）</p><h2 id="你以为到这就完了？"><a href="#你以为到这就完了？" class="headerlink" title="你以为到这就完了？"></a>你以为到这就完了？</h2><p>二分查找从提出到最后无Bug实现，期间经历了16年，要这么简单的就完结了。。。怕是没办法瞒天过海16年了</p><p>我们在上面实现的二分查找还是有个Bug隐藏着，那就是<code>middle = (left +right) / 2</code></p><p>如果当<code>left</code>和<code>right</code>数值足够大的时候，我们再这样求和时，<code>int</code>类型就越界啦~</p><p>那越界了咋搞呢？还记得我们之前有说过如何进行大整数求和吧？嗯，记得的话，那你还挺不错的，如果你用那种方式去解决它们求中间值时造成的越界…我只能说…你是不是傻啊…</p><p>其实我们稍微改一改middle 的求值方式就好了，从加法改成了减法，那么自然也就不会越界啦~</p><p>就是改成这样子<code>middle = left + (right - left) / 2</code>就好了~</p><p>我这几十年之后的马后炮，真酸爽</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>之前说的每周算法题，说实话，停更有好长一段时间了</p><p>今天这篇继上一篇，间隔时间估摸着有好几周了…emmmm </p><p>不是我不想在这个系列上保持持续更新，而是这货你们连个在看都不点，让我没有欲望继续写下去</p><p>你仔细看看我之前的每周算法题系列，就会发现，没有一篇是只说算法的，都是夹杂着其它的思想，或者是开发实践，又或者是一些别的经验</p><p>如果只是拿着LeetCode上的题目实现一遍，然后跟你们讲解一遍，我觉得这样做是没用任何意义，因为你们完全可以去Github上看人家的solution，一次性看几十个题都没问题，也可以直接去LeetCode一天刷个几十题，何苦还需要在我这看我BB叨呢…</p><p>最后为了证明你彻底掌握循环不变量的关键思想，给你们留个问题吧</p><p>我们在之前声明时<code>left = 0</code>，<code>right = len(arr) - 1</code>，现在将<code>right</code>改成<code>right = len(arr)</code>，我们后面在处理区间时，当<code>target &lt; arr[middle]</code>时，<code>left</code>和<code>right</code>又该怎么赋值呢？</p><p>给你们一个提示，我们在写<code>right = len(arr)-1</code>时的查询范围是<code>[left,right]</code>，而<code>right = len(arr)</code>时，查询的范围是<code>[left,right)</code>，注意查询区间的改变~</p><p>之所以给你们留个问题，是因为只看不做还不思考，是很难彻底弄明白的~</p><p>在底下留言给出你的思考吧</p><p><img src="http://ww1.sinaimg.cn/large/007OROpSgy1g3n1vc6jkvj30am09zgm6.jpg" alt></p><p>微信扫码关注公众号「闹闹吃鱼」，每周都有好分享，还可领取学习资源哦~不仅仅只是技术！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/007OROpSgy1g3n1tzs5ytj30gf0cvjvr.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;平时我们写程序的时候，总是莫名其妙的出现Bug，一鼓作气的写完一个接口后，经常被队友喷「你怎么一回
      
    
    </summary>
    
      <category term="算法" scheme="https://AdolphKevin.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="二分查找法" scheme="https://AdolphKevin.github.io/categories/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://AdolphKevin.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JS该如何取得URL里的参数？</title>
    <link href="https://AdolphKevin.github.io/2019/05/29/JS%E8%8E%B7%E5%8F%96URL%E5%8F%82%E6%95%B0/"/>
    <id>https://AdolphKevin.github.io/2019/05/29/JS获取URL参数/</id>
    <published>2019-05-29T13:37:59.334Z</published>
    <updated>2019-08-05T18:14:14.667Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/007OROpSgy1g3iprsx176j30gy0cuag2.jpg" alt></p><p>有一段时间没写过技术干货文了，这两天刚好遇到一个以前没太在意的一个功能实现–<strong>前端获取URL传递的参数</strong></p><p>掉了一堆头发后，想想还是写出来跟你们分享一下，以后要是你们遇到了也有个参考</p><p>要只是获取一些常规字符串到没什么难的，关键还有些乱七八糟的需求，什么同一个参数名传递了多次啊，传数组啊。搞来搞去就写了一大堆</p><p>先说说思路吧，<strong>如果你看这文章是想要解决问题，拿着代码直接用的话，就直接看最后面的Code实现以及使用方法吧</strong></p><h2 id="用框架思维分析问题"><a href="#用框架思维分析问题" class="headerlink" title="用框架思维分析问题"></a>用框架思维分析问题</h2><p>给你一个如下的URL：</p><blockquote><p><a href="http://NaoNao.com/?product=shirt&amp;color=blue&amp;newuser&amp;size=m#Hello" target="_blank" rel="noopener">http://NaoNao.com/?product=shirt&amp;color=blue&amp;newuser&amp;size=m#Hello</a></p></blockquote><p>将URL里传递的参数转换为<code>object</code>对象，这样我们在使用参数的时候也更为方便</p><p><strong>我曾多次强调框架思维</strong>，现在遇到这个问题了，我们就拿框架思维来分析一下，该怎样才能快速解决</p><p>首先是要了解我们的<strong>目的是什么</strong>？目的很简单，取得URL内传递的参数，并且解析成对象</p><p>接着再分析<strong>我们现在知道些什么</strong>？有一串URL</p><p>我们再来分析，如果从URL中获得传递的参数，也就是<strong>为了达到目的，我们该做些什么？</strong></p><p>URL的特征我们大致都知道，就是第一个<code>?</code>后面的字符串，都是传递的参数，但是<strong>有个特殊情况请不要忘记了</strong>，URL后面有时候会带上一个<code>#</code>，而<code>#</code>后面的内容，并不是我们要传递的参数，而是网页位置的标识符</p><p>如果URL中包含了<code>#</code>，<strong>我们只需要解析<code>?</code>到<code>#</code>之间的字符串就可以了</strong>，如果不包含，那么第一个<code>?</code>后所有的内容都是我们需要解析的</p><p>你可能觉得我是在说废话，这么明显的事情，只要不是白痴都能看得懂</p><p>我当然知道，只要不是白痴都能看得懂，<strong>但我为什么要强调呢？因为我们想要快速的解决问题，必须具备框架思维，也可以说是工程思维</strong></p><p>你可能有会说，这么简单的问题需要这样分析么？我们一看就知道了，闹闹你这是杀鸡用牛刀</p><p>虽说是杀鸡用牛刀，可<strong>要想培养自己的工程思维，那么必须保持刻意训练，直到随手拈来</strong></p><p>好了，分析完后，我们按照上面的思路来逐步实现，实现的时候可能会遇到其它的问题，到时候再分析，再解决</p><p>毕竟再牛逼的工程师，也不会在动手前就想的面面俱到，只能是<strong>在动手实现前尽可能的考虑周到，遇到问题时再快速的迭代更新</strong></p><h2 id="JS获取URL参数的过程"><a href="#JS获取URL参数的过程" class="headerlink" title="JS获取URL参数的过程"></a>JS获取URL参数的过程</h2><p>先用JS拿到URL，如果函数传参了URL，那就用参数。如果没传参，就使用当前页面的URL<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> queryString = url ? url.split(<span class="string">'?'</span>)[<span class="number">1</span>] : <span class="built_in">window</span>.location.search.slice(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><p>如果后面的字符串存在<code>#</code>，我们还得将<code>#</code>后面的字符串去掉，因为<code>#</code>后面的内容并不是我们需要获取的参数，而是网页位置的标识符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queryString = queryString.split(<span class="string">'#'</span>)[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>好了，把干扰的部分都移除后，我们可以开始安心的解析参数了，先将传递的参数分成数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = queryString.split(<span class="string">'&amp;'</span>);</span><br></pre></td></tr></table></figure><p>现在我们可以获得一个字符串数组<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'product=shirt'</span>, <span class="string">'color=blue'</span>, <span class="string">'newuser'</span>, <span class="string">'size=m'</span>]</span><br></pre></td></tr></table></figure></p><p>将字符串拆分成数组后，我们通过创建一个对象，用来存储我们所有的参数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br></pre></td></tr></table></figure></p><p>我们可以通过遍历数组<code>arr</code>，将它拆分成键值对。把这个字符串做成<code>key:value</code>的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = arr[i].split(<span class="string">'='</span>);</span><br></pre></td></tr></table></figure><p>接下来就是要为每一个变量<code>key</code>分配对应的值<code>value</code>，如果我们得到的<code>value</code>不是一个正确的参数，我们就用<code>true</code>来表示这个参数名存在，当然了，你也可以根据自己的实际情况来做改变</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> paramName = a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> paramValue = <span class="keyword">typeof</span>(a[<span class="number">1</span>]) === <span class="string">'undefined'</span> ? <span class="literal">true</span> : a[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>在这里我只是对<code>undefined</code>做了标记，如果是<code>NaN</code>，我是直接拿它当字符串处理了</p><p><strong>在这里有一个小坑得提醒一下</strong>，我们在调用函数，获取对象取值的时候，如果URL传递的<code>key</code>为大写，我们取对象时写的小写，那么结果就是为<code>undefined</code></p><p>比如URL为<code>http://NaoNao.com/?NamE=NaoNao</code>，如果不做大小写的处理，调用对象取值时<code>getAllUrlParams().NamE</code>才能取到值<code>NaoNao</code>，如果做了处理，我们使用时只需要全部写成小写/大写即可，例如<code>getAllUrlParams().name</code></p><p>我在这就全部转为小写了，如果你对大小写要求区分，那到时候把这段Code给去掉就好了<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">paramName = paramName.toLowerCase();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> paramValue === <span class="string">'string'</span>) paramValue = paramValue.toLowerCase();</span><br></pre></td></tr></table></figure></p><p>接下来我们就要去处理我们接受到的<code>paramValue</code>，<strong>这些参数可能是索引数组，非索引数组，又或者是常规字符串</strong></p><p><strong>如果是索引数组</strong>，我们需要将<code>paramValue</code>转换成数组，并且将索引对应的值，放入索引对应的位置</p><p><strong>如果是非索引数组</strong>，我们就要将<code>paramValue</code>放到数组中</p><p><strong>如果只是常规的字符串</strong>，我们就需要为我们的对象<code>obj</code>创建一个常规的属性，并为其分配值。</p><p><strong>如果这个key已经存在</strong>，那么我们就要将现有的<code>paramValue</code>从<code>key:value</code>转换为数组，并将它放到数组中</p><p>拿几个实际案例，感受一下我们要做什么吧</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 索引数组</span></span><br><span class="line">getAllUrlParams(<span class="string">'http://NaoNao.com/?colors[0]=red&amp;colors[2]=green&amp;colors[6]=blue'</span>);</span><br><span class="line"><span class="comment">// &#123; "colors": [ "red", null, "green", null, null, null, "blue" ] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非索引数组</span></span><br><span class="line">getAllUrlParams(<span class="string">'http://NaoNao.com/?colors[]=red&amp;colors[]=green&amp;colors[]=blue'</span>);</span><br><span class="line"><span class="comment">// &#123; "colors": [ "red", "green", "blue" ] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多次传递同一个key</span></span><br><span class="line">getAllUrlParams(<span class="string">'http://NaoNao.com/?colors=red&amp;colors=green&amp;colors=blue'</span>);</span><br><span class="line"><span class="comment">// &#123; "colors": [ "red", "green", "blue" ] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递了key，但是没传value</span></span><br><span class="line">getAllUrlParams(<span class="string">'http://NaoNao.com/?product=shirt&amp;color=blue&amp;newuser&amp;size=m'</span>);</span><br><span class="line"><span class="comment">// &#123; "product": "shirt", "color": "blue", "newuser": true, "size": "m" &#125;</span></span><br></pre></td></tr></table></figure><p>我做这写判断时用的是正则表达式，在这里就不解释正则了。。。毕竟解释起来篇幅就太长了，能看懂就尽量看吧</p><p>每个正则要解析什么，在注释中都写了例子，<strong>稍微了解点正则表达式的同学，多半也能看懂的</strong></p><p>对应的代码实现如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果paramName以方括号结束, e.g. colors[] or colors[2]</span></span><br><span class="line"><span class="keyword">if</span> (paramName.match(<span class="regexp">/\[(\d+)?\]$/</span>)) &#123;</span><br><span class="line">    <span class="comment">// 如果paramName不存在，则创建key</span></span><br><span class="line">    <span class="keyword">var</span> key = paramName.replace(<span class="regexp">/\[(\d+)?\]/</span>, <span class="string">''</span>);</span><br><span class="line">    <span class="keyword">if</span> (!obj[key]) obj[key] = [];</span><br><span class="line">    <span class="comment">// 如果是索引数组 e.g. colors[2]</span></span><br><span class="line">    <span class="keyword">if</span> (paramName.match(<span class="regexp">/\[\d+\]$/</span>)) &#123;</span><br><span class="line">        <span class="comment">// 获取索引值并在对应的位置添加值</span></span><br><span class="line">        <span class="keyword">var</span> index = <span class="regexp">/\[(\d+)\]/</span>.exec(paramName)[<span class="number">1</span>];</span><br><span class="line">        obj[key][index] = paramValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是其它的类型，也放到数组中</span></span><br><span class="line">        obj[key].push(paramValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理字符串类型</span></span><br><span class="line">    <span class="keyword">if</span> (!obj[paramName]) &#123;</span><br><span class="line">        <span class="comment">// 如果如果paramName不存在，则创建对象的属性</span></span><br><span class="line">        obj[paramName] = paramValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj[paramName] &amp;&amp; <span class="keyword">typeof</span> obj[paramName] === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果属性存在，并且是个字符串，那么就转换为数组</span></span><br><span class="line">        obj[paramName] = [obj[paramName]];</span><br><span class="line">        obj[paramName].push(paramValue);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是其它的类型，还是往数组里丢</span></span><br><span class="line">        obj[paramName].push(paramValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果你的URL的传参包含了一些特殊字符，比如空格。例如<code>url=&quot;NaoNao.com/?name=Nao%20Nao&quot;</code>，拿到对象值之后，是需要解码后才能获得正确的值的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> original = getAllUrlParams().name; <span class="comment">// 'Nao%20Nao'</span></span><br><span class="line"><span class="keyword">var</span> decode = <span class="built_in">decodeURIComponent</span>(original); <span class="comment">// 'Nao Nao'</span></span><br></pre></td></tr></table></figure><h2 id="具体实现以及使用方式"><a href="#具体实现以及使用方式" class="headerlink" title="具体实现以及使用方式"></a>具体实现以及使用方式</h2><p>下面是JS的具体的完整实现，你们复制回去就可以用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAllUrlParams</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 用JS拿到URL，如果函数接收了URL，那就用函数的参数。如果没传参，就使用当前页面的URL</span></span><br><span class="line">    <span class="keyword">var</span> queryString = url ? url.split(<span class="string">'?'</span>)[<span class="number">1</span>] : <span class="built_in">window</span>.location.search.slice(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 用来存储我们所有的参数</span></span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 如果没有传参，返回一个空对象</span></span><br><span class="line">    <span class="keyword">if</span> (!queryString) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// stuff after # is not part of query string, so get rid of it</span></span><br><span class="line">    queryString = queryString.split(<span class="string">'#'</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 将参数分成数组</span></span><br><span class="line">    <span class="keyword">var</span> arr = queryString.split(<span class="string">'&amp;'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 分离成key:value的形式</span></span><br><span class="line">        <span class="keyword">var</span> a = arr[i].split(<span class="string">'='</span>);</span><br><span class="line">        <span class="comment">// 将undefined标记为true</span></span><br><span class="line">        <span class="keyword">var</span> paramName = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">var</span> paramValue = <span class="keyword">typeof</span> (a[<span class="number">1</span>]) === <span class="string">'undefined'</span> ? <span class="literal">true</span> : a[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 如果调用对象时要求大小写区分，可删除这两行代码</span></span><br><span class="line">        paramName = paramName.toLowerCase();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> paramValue === <span class="string">'string'</span>) paramValue = paramValue.toLowerCase();</span><br><span class="line">        <span class="comment">// 如果paramName以方括号结束, e.g. colors[] or colors[2]</span></span><br><span class="line">        <span class="keyword">if</span> (paramName.match(<span class="regexp">/\[(\d+)?\]$/</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果paramName不存在，则创建key</span></span><br><span class="line">            <span class="keyword">var</span> key = paramName.replace(<span class="regexp">/\[(\d+)?\]/</span>, <span class="string">''</span>);</span><br><span class="line">            <span class="keyword">if</span> (!obj[key]) obj[key] = [];</span><br><span class="line">            <span class="comment">// 如果是索引数组 e.g. colors[2]</span></span><br><span class="line">            <span class="keyword">if</span> (paramName.match(<span class="regexp">/\[\d+\]$/</span>)) &#123;</span><br><span class="line">                <span class="comment">// 获取索引值并在对应的位置添加值</span></span><br><span class="line">                <span class="keyword">var</span> index = <span class="regexp">/\[(\d+)\]/</span>.exec(paramName)[<span class="number">1</span>];</span><br><span class="line">                obj[key][index] = paramValue;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是其它的类型，也放到数组中</span></span><br><span class="line">                obj[key].push(paramValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 处理字符串类型</span></span><br><span class="line">            <span class="keyword">if</span> (!obj[paramName]) &#123;</span><br><span class="line">                <span class="comment">// 如果如果paramName不存在，则创建对象的属性</span></span><br><span class="line">                obj[paramName] = paramValue;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj[paramName] &amp;&amp; <span class="keyword">typeof</span> obj[paramName] === <span class="string">'string'</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果属性存在，并且是个字符串，那么就转换为数组</span></span><br><span class="line">                obj[paramName] = [obj[paramName]];</span><br><span class="line">                obj[paramName].push(paramValue);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是其它的类型，还是往数组里丢</span></span><br><span class="line">                obj[paramName].push(paramValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数该怎么使用呢？</p><p>直接把URL参数当成对象调用就OK咯~</p><p>以文章开篇的URL为例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://NaoNao.com/?product=shirt&amp;color=blue&amp;newuser&amp;size=m#Hello</span></span><br><span class="line"></span><br><span class="line">getAllUrlParams().product; <span class="comment">// 'shirt'</span></span><br><span class="line">getAllUrlParams().color; <span class="comment">// 'blue'</span></span><br><span class="line">getAllUrlParams().newuser; <span class="comment">// true</span></span><br><span class="line">getAllUrlParams().NB; <span class="comment">// undefined</span></span><br><span class="line">getAllUrlParams(<span class="string">'http://NaoNao.com/?NaoNao=shuai'</span>).NaoNao; <span class="comment">// shuai</span></span><br></pre></td></tr></table></figure></p><p>用起来还是很简单方便的吧~</p><h2 id="不兼容IE的解决方案"><a href="#不兼容IE的解决方案" class="headerlink" title="不兼容IE的解决方案"></a>不兼容IE的解决方案</h2><p><strong>如果我们不需要考虑IE这种妖娆贱货，以及一些非常老版本浏览器</strong>，就用浏览器内<code>URLSearchParams</code>的接口吧。。。这个接口可以直接拿取URL内的参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// URL is http://NaoNao.com/?product=shirt&amp;color=blue&amp;newuser&amp;size=m</span></span><br><span class="line"><span class="keyword">const</span> urlParams = <span class="keyword">new</span> URLSearchParams(<span class="built_in">window</span>.location.search);</span><br><span class="line"><span class="comment">// 判断参数是否存在</span></span><br><span class="line"><span class="built_in">console</span>.log(urlParams.has(<span class="string">'product'</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 获取参数对应的值</span></span><br><span class="line"><span class="built_in">console</span>.log(urlParams.get(<span class="string">'product'</span>)); <span class="comment">// "shirt"</span></span><br></pre></td></tr></table></figure><p>这个接口还提供了更多成熟的方法，比如<code>keys()</code>,<code>Values()</code>,还有<code>entries()</code>，这个接口该怎么使用，直接去看官方文档就好了，用起来还是很虚浮的</p><p><img src="http://ww1.sinaimg.cn/large/007OROpSgy1g5pbxlmfqbj306008f0t1.jpg" alt></p><h2 id="微信扫码关注公众号「闹闹吃鱼」，每周都有好分享"><a href="#微信扫码关注公众号「闹闹吃鱼」，每周都有好分享" class="headerlink" title="微信扫码关注公众号「闹闹吃鱼」，每周都有好分享"></a>微信扫码关注公众号「闹闹吃鱼」，每周都有好分享</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/007OROpSgy1g3iprsx176j30gy0cuag2.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;有一段时间没写过技术干货文了，这两天刚好遇到一个以前没太在意的一个功能实现–&lt;strong&gt;前端获
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://AdolphKevin.github.io/categories/JavaScript/"/>
    
    
      <category term="URL解析" scheme="https://AdolphKevin.github.io/tags/URL%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>分享一个用Git装逼的小技巧~</title>
    <link href="https://AdolphKevin.github.io/2019/05/26/%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA%E7%94%A8Git%E8%A3%85%E9%80%BC%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7~/"/>
    <id>https://AdolphKevin.github.io/2019/05/26/分享一个用Git装逼的小技巧~/</id>
    <published>2019-05-26T12:46:46.940Z</published>
    <updated>2019-08-05T18:14:46.222Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/15072499-0e0cecc41d7e602b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>上次写完 <a href="https://mp.weixin.qq.com/s?__biz=MzU2NzczMzk5Nw==&amp;mid=2247483753&amp;idx=1&amp;sn=a8d654a7f61833b976f65a9e93b4f56c&amp;chksm=fc99faebcbee73fd8ef1b8bd777f064d90f5a8c5a628da6814065028264b174e09b1b3551176&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">实用且简单的Git教程，轻松搞定多人开发](https://mp.weixin.qq.com/s?__biz=MzU2NzczMzk5Nw==&amp;mid=2247483753&amp;idx=1&amp;sn=a8d654a7f61833b976f65a9e93b4f56c&amp;chksm=fc99faebcbee73fd8ef1b8bd777f064d90f5a8c5a628da6814065028264b174e09b1b3551176&amp;scene=21#wechat_redirect</a>)，得到的反馈信息简直超乎我的预期。</p><p>我前两天登掘金、简书、CSDN上把微信公众号的文章copy过去的时候，那阅读量和点赞数简直亮瞎我了……</p><p>按理来说，写的好，作为我公众号的读者们，你们都是我从别的平台辛辛苦苦一点一点的挖来的，对我更认可才对，居然没几个人给我点「好看」，也没见你们谁分享转发</p><p>我公众号所有文章的点赞数和阅读数全加起来，还不copy过去的文章的十分之一，让我很是伤心啊，点个「好看」表达一下对我文字的认可，我才更有动力写更好的文字与你们分享啊</p><p>作为一个主营微信公众号的号主，要靠别的平台的点赞数据，来获得成就感，我想我也是混的够惨了。</p><p>不过值得欣慰的是，最近有人私信我，跟我说“就是因为看了我那篇文章，才把GIT的命令行给记住的”。听了后我简直高兴的不行</p><p>GIt是个好东西，用了Git后，其它的版本控制器我是觉得真的不好用，而且命令行操作更是好用的不得了</p><p>上篇Git的命令行使用，基本已经解决了95%的问题。（只是从开发人员使用的角度）</p><p>这次做一点补充，<strong>再给你们分享个小技巧，巨好用，还能装逼！</strong><br><img src="https://upload-images.jianshu.io/upload_images/15072499-8e3b68ae10645f7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="Git-Log的进阶使用"><a href="#Git-Log的进阶使用" class="headerlink" title="Git Log的进阶使用"></a>Git Log的进阶使用</h2><p>Git查看日志，单独使用<figure class="highlight plain"><figcaption><span>log```来操作，每一个commit信息太多，干扰信息又太多，而且各种分支的合并也看不到，难受的很。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">今天给你们分享一个装逼的命令行，结合上一篇的文章[实用且简单的Git教程，5分钟搞定Git](https://www.jianshu.com/p/a3f0f55c88fb)，现在就完全可以摆脱第三方软件来使用Git了，复制粘贴即可使用</span><br><span class="line"></span><br><span class="line">&gt; git log --graph --pretty=format:&apos;%Cred%h%Creset - %C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit --date=relative </span><br><span class="line"></span><br><span class="line">给你们看看效果，是不是巨牛逼？</span><br><span class="line"></span><br><span class="line">![](https://upload-images.jianshu.io/upload_images/15072499-251d2d176bff7d3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">命令行这么长还这么复杂，我们该怎么记住呢？莫慌，再给你分享一个好东西</span><br><span class="line"></span><br><span class="line">那就是Git的一个别名操作```alias```，使用这个命令，可以极大的提高我们的命令行输入效率</span><br><span class="line"></span><br><span class="line">## alias效率为王</span><br><span class="line"></span><br><span class="line">我们经常使用的命令有```branch```，```checkout```，```commit```之类的，虽然简单，但是输入起来也是麻烦，作为一个程序员，开发程序就是为了提高效率的，能动一下手指解决问题，就绝不动两下，要把「懒」给发挥到极致才行</span><br><span class="line"></span><br><span class="line">比如看下面的例子：</span><br><span class="line"></span><br><span class="line">```git</span><br><span class="line">git config --global alias.ck checkout</span><br><span class="line"></span><br><span class="line">git config --global alias.br branch</span><br><span class="line"></span><br><span class="line">git config --global alias.ck commit</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><p>这样配置好了之后，我们以后使用这些命令，像<figure class="highlight plain"><figcaption><span>checkout```，直接输入```git ck```就能完事。是不是666？</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```alias.xx```点后面的```xx```就代表了我们设置的别名，使用的时候，直接输入别名就好了</span><br><span class="line"></span><br><span class="line">像上面那么长的```git log```，咱们完全就可以使用```alias```来提高效率，下面的命令行直接复制粘贴就能使用了~</span><br><span class="line"></span><br><span class="line">若是你不做任何修改，使用的时候输入```git lg```即可</span><br><span class="line">```git</span><br><span class="line">git config --global alias.lg &quot;log --graph --pretty=format:&apos;%Cred%h%Creset - %C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit --date=relative&quot;</span><br></pre></td></tr></table></figure></p><p>配个图给你们看看</p><p><img src="https://upload-images.jianshu.io/upload_images/15072499-1dc99c74735ed04f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>执行后，使用的时候直接打开控制台输入<code>git lg</code>即可，又装逼，又省事</p><p>顺便提示一下，Git的命令行操作时，复制是<code>ctrl+insert</code>，粘贴是<code>shift+insert</code>，查看日志时，按「回车键」可以加载更多日志信息，按<code>q</code>键是退出日志查看</p><p>在<code>merge</code>后的<code>commit</code>，偶尔会弹出一个Linux对话框让你写备注</p><p>此时需要用到Linux指令才能操作</p><p>按<code>i</code>进入对话框编辑模式，将<code>commit</code>的备注内容写好后<br>按<code>ESC</code>退出编辑模式<br>按<code>:</code>+<code>wq</code>退出并保存即可</p><h2 id="为什么要用命令行？"><a href="#为什么要用命令行？" class="headerlink" title="为什么要用命令行？"></a>为什么要用命令行？</h2><p>你们应该都知道，<strong>第三方界面化软件操作Git，本质上其实都是用的Git命令行，一些复杂的操作都是直接将GIT组合好后直接执行</strong>，只是软件把他们封装了起来，没让我们看到命令行罢了</p><p>之前我也是用可视化的第三方软件来使用Git命令行的操作，后来发现总是有着莫名其妙的问题，并且错误提示看起来就是一头雾水，后来干脆就学着使用命令行操作</p><p>使用命令行之后才发现，执行的速度以及准确度，<strong>比用第三方软件的效率要高的多</strong>，并且一些莫名其妙的问题也再也没遇见过了</p><p>因为软件是把一系列的Git命令给封装起来，而我们自己使用的时候，Git提交的逻辑顺序我们是很清楚的，这样一步一步走下来，只要逻辑是对的，就不会出错，就算出错了，<strong>命令行操作时，错在哪，该怎么修正，都提示的一清二楚</strong>，这也省下了我们拿着界面化软件的报错去找百度的时间。</p><p>刚开始用命令行操作的时候，是有一些不大习惯，但是用熟练之后，你完全就不会想打开第三方软件了~</p><p>当然了，<strong>技术只是一个工具，工具的目的就是为了提升效率</strong>，如果觉得使用GUI界面化的软件你的效率更高，那就按照自己的高效率方式去做就好了。</p><p>像我，我就是在追求效率的同时，还想着要能装装逼~~</p><p>我做为一个依赖Windows生态的码畜，一切都是可视化操作，唯一能有点能像电影里极客样的样子，也就是用Git命令行的时候了……</p><p>毕竟每次用Git时，屏幕上的命令框里，突突突的跳出这些命令，感觉自己就像电影里的极客那样帅</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>今天周末，也就是爬上来跟你们聊会儿，顺便分享两个小技巧。以后不出意外每周都会这样，当然了，我是指每周分享个小技巧什么的，心情不错的时候，就顺带逼逼叨一下</p><p>分享的小技巧什么的，分享的范围你们可以后台留言告诉我你们想要看什么方面的，我就多写写你们想要看的，反正趁着现在关注我的人不多，基本上每个人都能照顾到，现在不压榨我，还等什么时候呢？</p><p><img src="http://ww1.sinaimg.cn/large/007OROpSgy1g5pbxlmfqbj306008f0t1.jpg" alt></p><h2 id="微信扫码关注公众号「闹闹吃鱼」，每周都有好分享"><a href="#微信扫码关注公众号「闹闹吃鱼」，每周都有好分享" class="headerlink" title="微信扫码关注公众号「闹闹吃鱼」，每周都有好分享"></a>微信扫码关注公众号「闹闹吃鱼」，每周都有好分享</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/15072499-0e0cecc41d7e602b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240
      
    
    </summary>
    
      <category term="Git教程" scheme="https://AdolphKevin.github.io/categories/Git%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Git" scheme="https://AdolphKevin.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>为什么你的想法那么容易动摇？</title>
    <link href="https://AdolphKevin.github.io/2019/05/25/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E7%9A%84%E6%83%B3%E6%B3%95%E9%82%A3%E4%B9%88%E5%AE%B9%E6%98%93%E5%8A%A8%E6%91%87%EF%BC%9F/"/>
    <id>https://AdolphKevin.github.io/2019/05/25/为什么你的想法那么容易动摇？/</id>
    <published>2019-05-24T16:06:39.000Z</published>
    <updated>2019-08-05T18:14:29.263Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/15072499-99914df46f630528.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号：闹闹吃鱼"></p><blockquote><p>不知道大家有没有看过《奇葩说》，每当看到论题时，其实自己心中已有答案，但是随着双方的不断辩论，过程中自己的想法却也在不断的动摇，改变。更在有的时候，甚至会怀疑自己</p></blockquote><p>自己的观点不断随着外界因素的改变，是一件坏事情么？</p><p>自己观点容易动摇，最主要原因就是自己习惯性的思维方式，思维方式决定了我们最后所作的决定</p><p>有两种常见是思维方式，分别就是<strong>海绵式思维</strong>与<strong>淘金式思维</strong></p><h2 id="什么是海绵式思维？"><a href="#什么是海绵式思维？" class="headerlink" title="什么是海绵式思维？"></a>什么是<strong>海绵式思维</strong>？</h2><p>先来谈谈<strong>海绵式思维</strong></p><p>想想在我们刚进入某个行业开始学习的时候，面对一切的知识，面对权威、对书本的内容深信不疑。</p><p>自己就是像一块会吸水的海绵一样，想把一切都吸收进自己的身体里</p><p>这样做并不是没好处，有两个极大的优点</p><ul><li>可以快速的学习知识，吸收外部信息越多，越能体会到其中的千头万绪，为之后的复杂思考提供了坚实的基础</li><li>可以快速的学习高手的知识、思想，为我们成为一个有思想的人，奠定了一定高度的基础。</li></ul><p>不过这世界总是公平的，这货有如此好处的同时，还有一个非常致命的缺点：面对纷沓而来的各种信息，<strong>这种思维方式对我们进行信息的取舍提供不了任何帮助</strong>。如果我们始终依赖<strong>海绵式思维</strong>学习，那么我们在学习的道路上，对最新学习的内容将深信不疑。</p><p>为什么海绵式思维不能让我们对信息做出取舍呢？因为它本身是一种被动的学习方式，被动的学习，我们只需要认真理解并记忆，他们的知识就能被我们“学会”。</p><p>被动学习是轻松并愉快还高效的一种方式，不需要我们对各种信息进行深入的思考与求证，尤其是面对他人拿出井井有条并生动有趣的论证过程时，我们更是对之论证结果深信不疑。</p><p>可是，不管是在学习时，还是在人生路上，我们都要自己掌握主动权，我们的人生要我们自己主宰，享受过被动学习的快速与高效后，我们要建立起自己的世界观，转被动为主动。</p><h2 id="淘金式思维"><a href="#淘金式思维" class="headerlink" title="淘金式思维"></a><strong>淘金式思维</strong></h2><p>要说转被动为主动，那肯定离不开一个概念词<strong>淘金式思维</strong></p><p>淘金式思维是一种主动的思维形式，何为主动？就是我们需要知道，哪些东西是重要的，哪些东西是不重要的，选择重要的东西，抛弃无所谓的东西。</p><p>这个名词其实就已经非常的形象的解释了什么是主动，就像沙海中淘金，把廉价的沙石去除，只留下珍贵的黄金。反正黄金自己是不会从沙海中跑你手上的。</p><p>主动学习无疑是辛苦的，因为需要我们主动思考，依赖于自己的人生观、世界观、价值观等因素，去思考什么东西才是正确的，什么东西是值得学习的。</p><p>而不像被动学习那样胡吃海喝，什么都要。</p><p>在如今这个信息爆炸的时代，淘金式思维不仅能很好的帮助我们与对方进行互动，更能帮助我们筛选无用信息。</p><p>在互动的过程中，难免会对观点或者内容有着的不同见解，当在不同见解中找不同时，双方都能有更多的收获。</p><p>要说筛选无用信息，近两天登上微博热搜榜的《搜索引擎百度已死》一文，主要说了搜索引擎百度，在信息搜索时得到的结果良莠不齐，甚至低劣内容占据更多的搜索结果。</p><p>文中作者能判断内容优劣，无非就是利用淘金式思维做了筛选。</p><p>介绍了这么多两种思维的差距以及优劣，那我们该怎么培养<strong>淘金式思维</strong>呢？</p><p>其实培养淘金式思维也并非难事，归根结底，只是需要我们培养自己的主动意识。那该怎么主动呢？继续往下看就知道了</p><h2 id="批判性思维"><a href="#批判性思维" class="headerlink" title="批判性思维"></a>批判性思维</h2><p>说了这么多，都是为了给<strong>批判性思维</strong>做铺垫的。</p><p>不知道你们有没有遇到这种困惑？</p><blockquote><p>自己不论是小到物品选购，还是大到报考学校专业选择，只要自己在选择前，在网络上搜集了大量资料，或者咨询了周边亲戚朋友的各种建议之后，自己更是无法选择。</p></blockquote><p>因为这种情况就是因为我们没有自己的<strong>批判性思考</strong>，在信息大爆炸的时代背景下，我们需要能够自己独立思考，只有当我们有了自己的思考后，才能发出自己的声音。</p><p>上面介绍的海绵式思维与淘金式思维，两者都没有绝对的好处，没有谁能替代谁。</p><p>在批判性思维中，上述两种思维是需要综合运用的。在我们知识匮乏时，需要通过海绵式思维来快速积累自己的知识，当有了一定的知识储备后，自然就能建立起我们对内容的认知。</p><p>有了这些知识储备做为我们的基础，我们才有能力去对别的内容进行判断，才能拥有我们的自己的思想。</p><p>但是在使用批判式思维时，不要陷入了自己的思维陷阱中。看看高级与低级的区分，自然也就明白陷阱是什么</p><p>在Wiki百科中，对拥有批判思考者的高低，有着以下的定义</p><blockquote><p><strong>低级的批判思考者</strong>(即持有弱批判性思维者)人们称作「诡辩家」，他们有娴熟的思考技巧，却不管自身思维是否有明显问题，他们善于挖掘他人的思考漏洞，用种种手段、技巧赢得辩论、打动他人、谋取利益。  </p><p><strong>高级的批判思考者</strong>(即持有强批判性思维者)是公正无私的，他们试图评论一切推理的真正优点与缺失，无论出于自己或他人。他们不会控制他人或逃避真相，而是用有道德、负责任的态度思考问题，他们愿意聆听自己未必赞同的论点，如有更正确的推理，也愿意改变自己的观点或立场。</p></blockquote><p><strong>总结而言，我们需要时刻使用批判性思维看待自己的思维是否有问题。</strong></p><p>我们不能也不应该逃避真相，我们培养自己的批判性思维，不就是为了我们自己能在这信息错综复杂的时代拥有自己的思想，找到真相从而不随意被他人蛊惑吗？</p><p>好了，扯了这么多的内容，你能看到这，我觉得我们对<strong>海绵式思维</strong>，<strong>淘金式思维</strong>，<strong>批判性思维</strong>已经达成共识了。</p><p>那我就在这说说该怎么<strong>具体应用批判性思维</strong>吧</p><h2 id="批判性思维的具体应用"><a href="#批判性思维的具体应用" class="headerlink" title="批判性思维的具体应用"></a>批判性思维的具体应用</h2><p>在还未习惯批判性思维的思考方式时，我们需要找到套路，毕竟在没有自己的经验之前，学习前人的经验是最快且有成效的一种方式</p><p>先来看看套路是怎样的，我的总结如下三点</p><blockquote><ul><li>找观点</li><li>看结论</li><li>支撑观点的理由是逻辑正确</li></ul></blockquote><p>先来看一个例子，从实际情况出发，结合上面的套路，我们来看看实际情况是到底是怎样的。<br>以下实践用例引用于《学会提问》（第十版）</p><blockquote><p>学校的着装规定是对不当着装的限制，目的是营造一种专心致志的学习氛围。如果一个学生衣着不当地来上课，就有可能极大的分散其他同学的注意力。在校期间适用着装规定并不是限制学生的表达自由。不同于要求学生统一着装，着装规定仍旧允许学生自由选择自己的服装，只要不是被视为不当着装即可。</p></blockquote><p>咱们按照上述套路来解析一下上述的观点说明。（以下解析为我个人解析，并非书本中的解析）</p><p><strong>观点：</strong>学校该不该对着装有着限制？</p><p><strong>结论：</strong>学校应该限制学生的不当着装。</p><p><strong>理由：</strong>不当着装会影响学校的学习氛围，分散同学的注意力</p><p>将问题清晰的剥离出来后，我们就可以在我们现有的知识体系上去判断此结论是否成立</p><p>首先我们需要与表达者达成共识，什么才算是”不当着装”？这点在与作者达成共识之前，我们并不好否定或者承认其结论的正确与错误。<br>因为在某些人眼中，在不管男士女生，裤子没遮住膝盖，就属于不正当着装。<br>又或者在有些人眼中，衣服上写着不利于社会主义的话，才算是不正当着装。</p><p>再来看逻辑是否正确，学生的穿衣为什么会影响学校的学习氛围呢？<br>这个理由本是用来支撑“学校应该限制学生的不当着装”的结论，而这结论又是从何而来？<br>如果我相信这个结论是正确的，那为了考虑别的同学的正常学习，学校应该限制学生的不当着装自然也应该支持。<br>可我要是不相信不当着装会影响学习氛围，那后续的结论自然也就不成立了。</p><p>看完上述这个例子，我想你对批判性思维自然也会有了一些理解。</p><p>无非就是按照上面总结的套路来，生活中多思考，多运用。你会发现之后看到的世界，与你现在看到的世界，有了很大的不一样。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>每一个人都应该学会批判性思维，反复求证自己的观点的同时，也能更准确的分辨哪些人是在胡说八道，哪些人说的观点是真的有价值。</p><p>快过年了，不管是正儿八经的公司，还是邪门歪道的骗子。都想着冲一把业绩过个好年。大家正好可以多用用批判性思维，去辨别哪些是想收割你的骗子，哪些是想教你钓鱼</p><p><strong>一个观点只有经过自己不断的反复论证与修改，最后才能成为自己的信念</strong></p><p><img src="http://ww1.sinaimg.cn/large/007OROpSgy1g5pbxlmfqbj306008f0t1.jpg" alt></p><h2 id="微信扫码关注公众号「闹闹吃鱼」，每周都有好分享"><a href="#微信扫码关注公众号「闹闹吃鱼」，每周都有好分享" class="headerlink" title="微信扫码关注公众号「闹闹吃鱼」，每周都有好分享"></a>微信扫码关注公众号「闹闹吃鱼」，每周都有好分享</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/15072499-99914df46f630528.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240
      
    
    </summary>
    
      <category term="认知提升" scheme="https://AdolphKevin.github.io/categories/%E8%AE%A4%E7%9F%A5%E6%8F%90%E5%8D%87/"/>
    
    
      <category term="批判性思维" scheme="https://AdolphKevin.github.io/tags/%E6%89%B9%E5%88%A4%E6%80%A7%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>实用且简单的Git教程，5分钟搞定Git</title>
    <link href="https://AdolphKevin.github.io/2019/05/25/%E5%AE%9E%E7%94%A8%E4%B8%94%E7%AE%80%E5%8D%95%E7%9A%84Git%E6%95%99%E7%A8%8B%EF%BC%8C5%E5%88%86%E9%92%9F%E6%90%9E%E5%AE%9AGit/"/>
    <id>https://AdolphKevin.github.io/2019/05/25/实用且简单的Git教程，5分钟搞定Git/</id>
    <published>2019-05-24T16:00:00.000Z</published>
    <updated>2019-08-05T18:14:34.923Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/15072499-7f52aff5e9ee727d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>俗说金三银四，大部分人都选择在这个时候找工作</p><p>有拿完年终奖准备跳槽的，也有年前就辞职，已经休了一个长期年假的，还有刚走出校门的青涩少年们</p><p>换了新工作，肯定要接触新项目，现在绝大多数项目都是使用Git进行版本控制</p><p>这篇文章，<strong>主要目的是在多人开发中让你能熟练使用Git</strong></p><p>从实战出发，不大谈原理，只谈实际应用，省去大量的查找文档的时间</p><p>入职新公司，接触新项目，基本是不需要你自己搭建Git项目来托管code的，所以这里就不谈搭建了，只谈在开发实战时，如何使用Git</p><p>文末有总结，便于查阅</p><p><strong>第一件事，肯定就是先安装Git了</strong></p><p>官网下载Git比较麻烦，需要有梯子来帮助你，才能摸到它，这里直接给你一个Github上的镜像地址供你下载安装</p><blockquote><p><a href="https://github.com/waylau/git-for-win" target="_blank" rel="noopener">https://github.com/waylau/git-for-win</a></p></blockquote><p>若不会安装，请移步搜索引擎，搜索Git安装教程，本文不过多描述安装过程</p><h2 id="第一次使用Git"><a href="#第一次使用Git" class="headerlink" title="第一次使用Git"></a>第一次使用Git</h2><p>安装好后，直接打开Git Bash，也就是Git 的控制台程序，就可以开始使用了</p><p>第一次使用Git，需要先配置自己的邮箱与名称</p><p>配置邮箱地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email &quot;NaoNao.@nao.com&quot;</span><br></pre></td></tr></table></figure></p><p>配置用户名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;NaoNao&quot;</span><br></pre></td></tr></table></figure></p><p>配置完，Git不会给出任何提示，Unix的逻辑就是，没有提示就是最美的提示。</p><p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><p>要想查看是否配置成功，依然是使用上述命令，把引号以及引号内的内容去掉即可。</p><h2 id="拉取项目"><a href="#拉取项目" class="headerlink" title="拉取项目"></a>拉取项目</h2><p>配置好我们的个人信息后，自然也就需要拉取项目了</p><p>在磁盘中新建好存放项目的文件夹，进入文件夹点击鼠标右键，选择Git Bash即可</p><p>温馨提示：使用Git托管的项目，有两种地址，Https与SSH。</p><p><strong>使用Https地址</strong>拉取，验证一次密码后，以后每次拉取/推送的时候不再需要验证密码。</p><p><strong>使用SSH地址</strong>拉取的项目，每次拉取/推送的时候都需要密码验证。<br>各位读者自己抉择。</p><p>我的项目地址是 <a href="https://github.com/AdolphKevin/NaoNao.git" target="_blank" rel="noopener">https://github.com/AdolphKevin/NaoNao.git</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/AdolphKevin/NaoNao.git</span><br></pre></td></tr></table></figure></p><p>将你的项目地址替换掉我的项目地址即可</p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>说分支管理之前，在此做个<strong>背景说明</strong>：一般在项目开发中会有2个主分支（master与develop）</p><p>master分支上的内容是发布在<strong>生产环境</strong>运行的内容</p><p>develop分支是所有开发人员<strong>开发完成</strong>发布到测试环境的内容</p><p>其它各种feature分支都是各位开发人员在开发时拉取使用的分支</p><p>此文，也沿用此方式，各位读者按照自己实际情况判断</p><p>拉取下来后，我们要进行开发，肯定不能在master分支上开发，一般在项目上都会有各种分支</p><p>项目clone下来，首先就是查看分支了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure></p><p>加上-r是代表查看远程仓库的分支，要是查看本地分支，只需要把-r去掉即可，-r是remote的简写</p><p>查看远程分支，所有的分支名前均会带有origin/ 的前缀，这个前缀代表着远程分支，拉取远程分支，填写远程分支名时不需要带上origin/</p><p>接到开发任务，我们需要从远程仓库上将我们需要开发的分支拉取到本地<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin x(远程分支名):y(本地分支名)</span><br></pre></td></tr></table></figure></p><p>使用上述代码，可以将远程分支拉取到本地，并创建本地分支</p><p>接着就是要将刚刚创建的本地分支与远程分支做关联了，做了关联之后，拉取更新与推送都不需要再指定分支名称<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream-to=origin/x(远程分支名)  y(本地分支名)</span><br></pre></td></tr></table></figure></p><p>其中，x是你本地分支对应的远程分支；y是你当前的本地分支。</p><h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><p>做完关联后，咱们就需要切换分支，在特定的分支上去进行开发任务<br>先查看本地分支，找到我们需要开发的分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></p><p>再切换到我们需要开发的分支上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout y(分支名)</span><br></pre></td></tr></table></figure></p><h2 id="提交内容"><a href="#提交内容" class="headerlink" title="提交内容"></a>提交内容</h2><p>我们在自己的分支上按照需求完成了开发任务，接着就是将我们开发的内容提交到远程仓库了</p><p>虽然咱们所在的分支，除了自己之外，按理说是没人会在自己这个分支上再进行开发，所以推送前拉取更新也不很必要</p><p>但是为了避免不必要的麻烦，提交之前还是先拉取一下最新的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure></p><p>获取了最新数据后，如果有别的同事动了咱们的分支，那肯定得先解决一下文件的冲突，若没有人动，那也就不用处理了</p><p>接着将我们添加/修改的文件提交到本地暂存区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add xxx(文件名)</span><br></pre></td></tr></table></figure></p><p>xxx代表着文件名。当然，开发时咱们基本上很少只修改/添加一个单独的文件，当修改或添加了很多文件时，让我们一个一个文件的add，能把人给累死</p><p>所以Git也给出了批量add的方法，简单粗暴<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -A</span><br></pre></td></tr></table></figure></p><p>-A是All的缩写，git add all 可以提交未跟踪、修改和删除文件。<br>.git add . 可以提交未跟踪和修改文件，但是不处理删除文件。</p><p>提交到暂存区后完成后就是将改动内容全部提交<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;提交到暂存区&quot;</span><br></pre></td></tr></table></figure></p><p>引号内的文字，是此次提交内容的一个说明描述，以后看日志时也便于知道此次进行了什么内容的修改</p><p>提交完后就是将本次修改的内容推送至远程仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure></p><p>好了，到这里push的时候，坑来了~~~</p><p>如果是自己一个人的项目，此时如何push都没问题，但问题就出在，咱们是多人开发的项目，咱们的分支是需要与主分支合并(merge)。</p><p>别的同事的任务完成了，早已推送到我们将要合并的develop分支上了</p><p>所以我们在push之前需要进行code merge ，将develop分支上的内容merge到我们当前的feature分支上</p><h2 id="代码合并"><a href="#代码合并" class="headerlink" title="代码合并"></a>代码合并</h2><p>此时我们在feature分支上已经将修改内容commit了<br>需要将develop分支的内容合并到当前分支，先切换分支到develop上，再获取一次更新<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure></p><p>这里切换到develop分支上获取更新时有个小坑，咱们暂且按照一切顺利来处理，后面再说一些常见的意外情况的处理。</p><p>获取完更新后，再切换到我们的feature分支上，将develop的内容合并到我们的feature分支上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature</span><br></pre></td></tr></table></figure></p><p>合并某分支到当前分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge develop</span><br></pre></td></tr></table></figure></p><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>执行merge后，如果有冲突，控制台会将有冲突的文件名展示出来，我们按照文件名找到对应文件，将冲突给解决掉后。</p><p>打开文件我们可以看到冲突的内容，例如：</p><blockquote><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>hello world feature<br>\=======<br>hello world develop<br>>&gt;&gt;&gt;&gt;&gt; develop</p></blockquote><p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容</p><p><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;与=======之间</code>的内容为<strong>当前分支</strong>的内容</p><p><code>=======与&gt;&gt;&gt;&gt;&gt;&gt;</code>之间的内容为<strong>develop分支</strong>的内容（换句话说：就是需要<strong>被合并的分支</strong>内容）</p><p><strong>将不需要保留的内容删除即可解决冲突</strong></p><p>解决冲突后，我们再将当前的feature分支推送到远程仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure></p><p>执行完本命令行后，即可将本地分支内容推送至远程仓库</p><h2 id="获取更新时的意外情况"><a href="#获取更新时的意外情况" class="headerlink" title="获取更新时的意外情况"></a>获取更新时的意外情况</h2><p>前面说从feature分支切换到develop分支拉取更新时，会有个小坑，因为有时候Git会报错</p><blockquote><p>Git pull - Please move or remove them before you can merge</p></blockquote><p>这个错误是因为无论原始文件中.gitignore 文件的内容是什么，文件都被添加到远程存储库中。</p><p>由于文件存在于远程存储库中，因此git也必须将它们提取到本地工作树，因此会抱怨文件已经存在。 </p><p>.gitignore 仅用于扫描新添加的文件，它与已添加的文件没有任何关系。</p><p>因此，解决方案是删除工作树中的文件并提取最新版本。或者长期解决方案是如果错误地添加了文件，则从存储库中删除文件。</p><p>这时我们在develop 分支上删除当前目录下没有被track过的文件和文件夹<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -d -f</span><br></pre></td></tr></table></figure></p><p>现在重新获取更新即可</p><h2 id="开发到一半，却需要切换分支"><a href="#开发到一半，却需要切换分支" class="headerlink" title="开发到一半，却需要切换分支"></a>开发到一半，却需要切换分支</h2><p>软件开发中，Bug就像家常便饭一样。有了Bug就需要修复，在Git中，由于分支是如此的强大，所以，在实战中，每个Bug都是通过一个新的临时分支来修复，修复后，将Bug分支合并到develop与master两个分支上，然后将临时分支删除</p><p>注意：将Bug分支合并到develop与master两个分支上，是在远程仓库完成。在本地，是需要将develop与master分支先获取最新，然后将这两分支分别合并在Bug分支上，解决冲突后直接推送Bug分支即可</p><p>可我们在feature分支上开发功能开发到一半，leader突然跑来告诉我们，生产环境出现了一个Bug，需要咱们紧急修复，咱们兴致勃勃的使用<code>git checkout Bug</code>命令，打算切换到Bug分支上去修复Bug</p><p>结果……Git却告诉我们，无法切换过去，因为我们目前所在分支没有提交……</p><p>可我们若要完成开发任务再去修复Bug，可能需要好几个小时甚至几天时间才能完成，而Bug修复却是紧急任务，这该如何是好呢？</p><p>问题不大，不慌。此时我们可以将当前分支开发的工作状态储藏下来，待我们解决了Bug，再恢复我们现在的状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure></p><p>执行完上述命令后，我们再来看看我们工作区是否干净<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></p><p>我们发现工作区非常干净，此时我们就可以顺利的执行<figure class="highlight plain"><figcaption><span>checkout Bug```到Bug分支上去修改Bug了</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">咱们现在将Bug也解决了，也推送了，现在又回到feature分支继续咱们之前的任务了，切换回feature分支后，之前修改的内容也没有恢复啊！说好的储藏了工作状态呢？</span><br><span class="line"></span><br><span class="line">咱们就来看看所有储藏的工作</span><br><span class="line">```git</span><br><span class="line">git stash list</span><br></pre></td></tr></table></figure></p><p>使用上述命令，Git会将所有的储藏工作罗列出来，当我们想要恢复其中某一个储藏状态时，指定其名字就好了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure></p><p>上述的stash@{0} 是当前分支储藏的工作名，各位读者根据自己的<figure class="highlight plain"><figcaption><span>stash list ```中的内容，自行替换</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">切换后，确认完当前状态无误了，就可以将之前保存的储藏删除</span><br><span class="line">```git</span><br><span class="line">git stash drop stash@&#123;0&#125;</span><br></pre></td></tr></table></figure></p><p>觉得要执行两行命令比较麻烦？没关系，还有一次性解决问题的方法<br>切换后并自动删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git stash pop stash@&#123;0&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><p>不过我个人不大推荐这种方式，万一咱们恢复的储藏指定错了呢，要恢复起来还挺麻烦的。</p><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>在开发时，总有需要回退到某个版本的时候，不然用版本控制系统干嘛？是吧</p><p>我们先来看看我们的历史版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure></p><p>现在控制台输出了最近三次提交的日志信息，友情提示一下，按键盘Q可退出，按回车可查看更多的日志</p><p>要是嫌弃输出的内容过于冗杂，可以让Git显示个简单版<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=oneline</span><br></pre></td></tr></table></figure></p><p>加上一个<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">现在我们可以根据当时commit时填写的描述信息，来判断哪一个ID是我们想要回退的版本</span><br><span class="line"></span><br><span class="line">版本的回退，有两种常用的方式</span><br><span class="line"></span><br><span class="line">回退到上一个版本</span><br><span class="line">```git </span><br><span class="line">git reset --hard HEAD</span><br></pre></td></tr></table></figure></p><p>根据commit的ID，回退到指定版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard commit_id</span><br></pre></td></tr></table></figure></p><p>commit_id这个版本号没必要写全，只需要写6位以上就差不多了，Git能自己找到它，若存在前6位重复ID，那再多加几位就好了</p><p>版本的回退也非常的简单吧，Git的命令行操作写到这儿，也进入尾声了。上述的命令基本可以满足日常的使用</p><h2 id="写在最后的总结"><a href="#写在最后的总结" class="headerlink" title="写在最后的总结"></a>写在最后的总结</h2><p>Git命令行的操作，使用起来并不复杂，作为开发人员，要是没有深入了解Git的意愿，会用就行了，使用Git的要领就是大量使用分支<br>总结一下本文牵扯到的git操作<br><code>git config --global user.name</code>查看用户名或配置用户名</p><p><code>git config --global user.email</code>查看email或配置email</p><p><code>git clone</code>将远程仓库的项目克隆到本地</p><p><code>git branch</code>查看分支</p><p><code>git branch -r</code>查看远程分支</p><p><code>git branch &lt;name&gt;</code>创建分支</p><p><code>git fetch origin origin/remote_branch:your_branch</code>将远程分支下载到本地，并创建分支</p><p><code>git branch --set-upstream-to=origin/remote_branch  your_branch</code>将本地分支与远程分支做关联</p><p><code>git pull</code>获取更新</p><p><code>git clean -d -f</code>删除当前目录下没有被track过的文件和文件夹</p><p><code>git merge &lt;name&gt;</code>将目标分支合并到当前分支</p><p><code>git add</code>将内容添加到暂存区</p><p><code>git commit</code>将添加的内容提交</p><p><code>git push</code>将本地提交内容推送到远程仓库</p><p><code>git checkout</code>切换分支</p><p><code>git branch -d &lt;name&gt;</code>删除分支</p><p><code>git stash</code>储藏当前分支所有内容</p><p><code>git stash list</code>查看当前分支储藏列表</p><p><code>git stash apply</code>恢复指定储藏内容</p><p><code>git stash drop</code>删除指定储藏内容</p><p><code>git stash pop</code>恢复并删除指定储藏内容</p><p><code>git status</code>显示工作目录和暂存区的状态</p><p><code>git log</code>显示commit的详细日志</p><p><code>git log --pretty=oneline</code>只显示commit的ID与描述</p><p><code>git reset --hard HEAD</code>回退到最近的一个版本</p><p><code>git reset --hard commit_id</code>根据commit_id回退到指定版本</p><p><img src="http://ww1.sinaimg.cn/large/007OROpSgy1g5pbxlmfqbj306008f0t1.jpg" alt></p><h2 id="微信扫码关注公众号「闹闹吃鱼」，每周都有好分享"><a href="#微信扫码关注公众号「闹闹吃鱼」，每周都有好分享" class="headerlink" title="微信扫码关注公众号「闹闹吃鱼」，每周都有好分享"></a>微信扫码关注公众号「闹闹吃鱼」，每周都有好分享</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/15072499-7f52aff5e9ee727d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240
      
    
    </summary>
    
      <category term="Git教程" scheme="https://AdolphKevin.github.io/categories/Git%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Git" scheme="https://AdolphKevin.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>在VsCode中搭建Go开发环境，手把手教你配置</title>
    <link href="https://AdolphKevin.github.io/2019/05/18/%E5%9C%A8VsCode%E4%B8%AD%E6%90%AD%E5%BB%BAGo%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%EF%BC%8C%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E9%85%8D%E7%BD%AE/"/>
    <id>https://AdolphKevin.github.io/2019/05/18/在VsCode中搭建Go开发环境，手把手教你配置/</id>
    <published>2019-05-17T16:00:00.000Z</published>
    <updated>2019-08-05T18:31:48.592Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/007OROpSgy1g5pd20bhroj30h90d9ag1.jpg" alt></p><p>前几天我聊了聊我自己从一个什么都不懂的小白，到现在只懂一点的学习历程</p><p>所谓万事开头难，学习Go语言最难的时候，也就是咱们啥都不知道的时候</p><p>之前我说了我学Go语言入门花了好几个晚上，这个时间不是花费在学习Go语言语法上，而是花在了搭建环境上…<strong>这篇文，我把我当初所有踩的坑都写到了</strong></p><p>我自己的开发环境是Windows 10 +VS Code ，都知道VS Code是一个可以让开发者自己高度定制化的编译器，而也正是因为这一点，从0开始搭建一个开发环境简直是累的一匹</p><p>之前有好些个童鞋来私聊我，问我编译器选择和配置的事情，我都是推荐使用VsCode，那<strong>今天就说说怎么把VSCode配置成Golang的编译器吧</strong></p><p>因为我手上只有Windows的电脑，所以就只能说下Windows环境如何配置了</p><h2 id="Golang的安装"><a href="#Golang的安装" class="headerlink" title="Golang的安装"></a>Golang的安装</h2><p>先去官网上下载Golang的安装包：<a href="https://golang.org/dl/" target="_blank" rel="noopener">点击访问下载地址</a></p><p>Windows的安装就很简单了，打开安装包后，一直Next就好了。安装时记好自己的安装路径，我自己就默认安装到C盘了</p><p><img src="http://ww1.sinaimg.cn/large/007OROpSgy1g5pd2a730nj30ks03cq2z.jpg" alt></p><p>安装好Go安装包后，需要配置环境变量，印象中记得Go在1.6版本后，这些环境变量都不需要我们手动配置了，安装的时候都会自动配置好</p><p>不过为了避免你们有些人进行了一些蛇皮操作，导致安装包没有自动配置环境变量，我这还是简单唠嗑一下环境变量的配置吧（已经配置好了就不用看了，直接看下一部分吧）</p><h2 id="Go环境变量配置"><a href="#Go环境变量配置" class="headerlink" title="Go环境变量配置"></a>Go环境变量配置</h2><p>所谓千言万语不如一张图，给你们截了图，也在图上做了标注，按着图片上的步骤来就好了，简单又明了</p><p><img src="http://ww1.sinaimg.cn/large/007OROpSgy1g5pd2lrnbpj311u0igthq.jpg" alt></p><p>配置<code>GOPATH</code>的的时候，可以看到下图，我路径设为了<code>E</code>盘，是因为<code>GOPATH</code>是我们的工作区，说白了就是我们做项目时放代码的地方，所以自己随便设置就好了</p><p><img src="http://ww1.sinaimg.cn/large/007OROpSgy1g5pd2s5kqzj30gl09l74m.jpg" alt></p><p>如果要变更<code>GOPATH</code>的路径，建议把原来<code>GOPATH</code>里的<code>pkg</code>、<code>bin</code>、<code>src</code>三个文件夹也复制过去，不然到时候我们开发时又要重新配置依赖包，不知情的你，可能还认为出BUG了呢</p><p><code>GOROOT</code>是Go的安装路径，<code>Path</code>变量里的选择安装路径里的<code>bin</code>文件路径就好了</p><p><img src="http://ww1.sinaimg.cn/large/007OROpSgy1g5pd2zeh5pj30oh0g20ut.jpg" alt></p><h2 id="配置Go开发环境"><a href="#配置Go开发环境" class="headerlink" title="配置Go开发环境"></a>配置Go开发环境</h2><p>我是提倡使用VSCode，所以也就只说VSCode了，如果你们热爱别的编译器，那我在这也只能告诉你如何安装Go的依赖包了…</p><p>打开我们的VSCode，安装<code>Go</code>插件，就这一个就可以了</p><p><img src="http://ww1.sinaimg.cn/large/007OROpSgy1g5pd377hdlj30k60a00uv.jpg" alt></p><p>好像没有梯子还不给下载，如果安装失败会提示你从网页上去下载到本地安装。<strong>以防万一你们下载不了，我把这个插件下载好打包放在公众号里了，你们直接在我公众号后台回复「插件」就可以拿到下载地址</strong></p><h2 id="安装Go的依赖包"><a href="#安装Go的依赖包" class="headerlink" title="安装Go的依赖包"></a>安装Go的依赖包</h2><p>兴致勃勃的打开了编译器，刚准备写个<code>Hello World</code>震惊世界的，结果第一行<code>package</code>都还没有写完，VSCode就给我这个提示……</p><p><img src="http://ww1.sinaimg.cn/large/007OROpSgy1g5pd3dcy9ej30d4085t93.jpg" alt></p><p>天真的你一而再再而三的点<code>Install All</code>，放心，不管用的，咱家的墙比天还高，搭梯子也翻不过去</p><p>不信？你看呗</p><p><img src="http://ww1.sinaimg.cn/large/007OROpSgy1g5pd3ljyhzj30f0084q39.jpg" alt></p><p>看到各种Failed，心里一万匹什么来着？不管了，反正就是万马奔腾吧</p><p>那咋办？就这样不管了？还没入门就放弃？</p><p>放心吧，有闹闹我在，怎么说今天也得让你用VSCode写个<code>Hello Word</code>爽爽</p><p>当<code>go get</code>不好使的时候，<strong>咱们就先去Github上把需要的package下载到本地，建议用Git把包给<code>Clone</code>下来，以后包有更新了，直接<code>pull</code>就可以更新</strong>，再把包给重新安装一次就好了</p><p><strong>此时VSCode提示的<code>Failed</code>就有用了</strong>，比如提示了<code>Installing github.com/ramya-rao-a/go-outline FAILED</code>，我们直接把网址复制下来放到浏览器，就可以看到这个Github的仓库</p><p>拿到下载链接后直接<code>clone</code>到本机上</p><p><strong>下载好了放哪里呢？放<code>GOPATH</code>的<code>src</code>路径下面或者<code>GO ROOT</code>的<code>src</code>下都可以</strong></p><p>只是<strong>文件夹命名要按照网址路径命名，这点一定要注意</strong>，如果不明白，下面我有举例说明</p><p>像<code>golang.org/x/tools/cmd/guru</code>这种不是在Github上的怎么搞？其实跟放在Github上的包下载是一样的操作，直接把这段链接放到浏览器里就可以打开网站，网站里面会有下载地址的，如下图</p><p><img src="http://ww1.sinaimg.cn/large/007OROpSgy1g5pd3slqucj30or0bigmf.jpg" alt></p><p><strong>如果不知道自己的<code>GOPATH</code>或者<code>GOROOT</code>路径在哪里</strong>，可以按<code>win+R</code>键，输入<code>cmd</code>，打开「命令提示符」输入<code>go env</code>，即可看到自己的<code>GOPATH</code>路径以及<code>GOROOT</code>路径。也可以像文章开篇那样，跑去环境变量配置的地方找</p><p>好了，拿个实际案例跟你们说说，以刚刚<code>github.com/ramya-rao-a/go-outline</code>这个包为例</p><p>打开链接<code>github.com/ramya-rao-a/go-outline</code></p><p>将这个包<code>clone</code>到本地的<code>GO PATH</code>路径下（我是放在<code>GO PATH</code>路径下的，你们若是不想<code>GO PATH</code>内存在与自己项目无关的文件，可以放在<code>GO ROOT</code>路径下）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ramya-rao-a/go-outline.git</span><br></pre></td></tr></table></figure><p>这个<code>package</code>的路径最后是这样的，如下图：</p><p><img src="http://ww1.sinaimg.cn/large/007OROpSgy1g5pd43111vj30l604qq38.jpg" alt></p><p><strong>悄悄地告诉你</strong>，其实只要在<code>src</code>目录下打开<code>bash</code>执行<code>clone</code>就ok了~哈哈哈哈哈</p><p>依赖包都下载好后，就可以进行安装了。可以在<code>CMD</code>中，或者直接在VSCode里按<code>Ctrl + `</code>打开<code>TERMINAL</code>进行安装。</p><p>输入<code>go install</code>命令，执行<code>pkg</code>的安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">go install golang.org/x/tools/go/gcexportdata</span><br><span class="line">go install github.com/mdempsky/gocode</span><br><span class="line">go install golang.org/x/tools/cmd/guru</span><br><span class="line">go install golang.org/x/tools/cmd/gorename</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>说到这，我想也差不多了，<strong>剩下的我相信你们自己也能搞定</strong>，毕竟我想让你们知道该怎么弄，这样以后你们要使用其它的第三方依赖包时，也知道该如何下载安装</p><p><strong>如果实在还没弄明白，可以关注我公众号「闹闹吃鱼」，有什么不明白的我可以为你解答</strong></p><h2 id="Hello-Word"><a href="#Hello-Word" class="headerlink" title="Hello Word"></a>Hello Word</h2><p>好了，编译器已经配置好了，接下来就是我们的<code>Hello Word</code>了</p><p>因为<code>GOPATH</code>是我们的工作区，所以我们自己搭建的项目，也要放在<code>GO PATH</code>的<code>src</code>路径下，文件路径如下图所示：</p><p><img src="http://ww1.sinaimg.cn/large/007OROpSgy1g5pd4eeig1j30k603yt8u.jpg" alt></p><p>一切就绪，就差Code~</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"Hello word"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯哼？到这步了，该试试怎么运行了，那就直接运行好了~<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go run hello.go</span><br></pre></td></tr></table></figure></p><p>可以看到咱们想要的结果出来了<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![](http://ww1.sinaimg.cn/large/007OROpSgy1g5pd5rpbyoj30dq01wq2v.jpg)</span><br><span class="line"></span><br><span class="line">## VS Code配置</span><br><span class="line">用了编译器，还要用命令行来运行程序，那要VS Code干嘛？</span><br><span class="line"></span><br><span class="line">我们熟悉的Debug，按了F5没效啊！还是提示我有问题</span><br></pre></td></tr></table></figure></p><p>那我们就来调整下Debug的配置好了，如下图所示：</p><p><img src="http://ww1.sinaimg.cn/large/007OROpSgy1g5pd5lu7lzj30l509st9d.jpg" alt></p><p>launch.json 文件内的内容，将下面的配置全部复制上去就好了~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;: &quot;LaunchGo&quot;,</span><br><span class="line">            &quot;type&quot;: &quot;go&quot;,</span><br><span class="line">            &quot;request&quot;: &quot;launch&quot;,</span><br><span class="line">            &quot;mode&quot;: &quot;auto&quot;,</span><br><span class="line">            &quot;remotePath&quot;: &quot;&quot;,</span><br><span class="line">            &quot;port&quot;: 5546,</span><br><span class="line">            &quot;host&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">            &quot;program&quot;: &quot;$&#123;fileDirname&#125;&quot;,</span><br><span class="line">            &quot;env&quot;: &#123;</span><br><span class="line">                &quot;GOPATH&quot;: &quot;E:/GoCode&quot;,</span><br><span class="line">                &quot;GOROOT&quot;: &quot;C:/Program Files/Go&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;args&quot;: [],</span><br><span class="line">            //&quot;showLog&quot;: true</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置好后，我们在<code>hello.go</code>文件内，直接按F5就能进入调试状态啦~</p><p>为了让你们在编写Go项目时有跟我一样的良好体验，我把我Vs Code的设置也拿给你们</p><p>下面这张图是如何打开<code>setting.json</code>文件</p><p><img src="http://ww1.sinaimg.cn/large/007OROpSgy1g5pd4zinekj30hd0f73zi.jpg" alt></p><p>打开之后把下面的内容全部Copy进去就好了，其中的<code>go.goroot</code>与<code>go.gopath</code>，你需要改成你自己的Go环境路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;editor.wordWrap&quot;: &quot;on&quot;,</span><br><span class="line">    &quot;editor.minimap.renderCharacters&quot;: false,</span><br><span class="line">    &quot;editor.minimap.enabled&quot;: false,</span><br><span class="line">    &quot;terminal.external.osxExec&quot;: &quot;iTerm.app&quot;,</span><br><span class="line">    //&quot;go.useLanguageServer&quot;: true,</span><br><span class="line">    &quot;go.docsTool&quot;: &quot;gogetdoc&quot;,</span><br><span class="line">    &quot;go.testFlags&quot;: [&quot;-v&quot;,&quot;-count=1&quot;],</span><br><span class="line">    &quot;go.buildTags&quot;: &quot;&quot;,</span><br><span class="line">    &quot;go.buildFlags&quot;: [],</span><br><span class="line">    &quot;go.lintFlags&quot;: [],</span><br><span class="line">    &quot;go.vetFlags&quot;: [],</span><br><span class="line">    &quot;go.coverOnSave&quot;: false,</span><br><span class="line">    &quot;go.useCodeSnippetsOnFunctionSuggest&quot;: false,</span><br><span class="line">    &quot;go.formatTool&quot;: &quot;goreturns&quot;,</span><br><span class="line">    &quot;go.gocodeAutoBuild&quot;: false,</span><br><span class="line">    &quot;go.goroot&quot;: &quot;C:\\Program Files\\Go&quot;,</span><br><span class="line">    &quot;go.gopath&quot;: &quot;E:\\GoCode&quot;,</span><br><span class="line">    &quot;go.autocompleteUnimportedPackages&quot;: true,</span><br><span class="line">    &quot;go.formatOnSave&quot;: true,</span><br><span class="line">    &quot;window.zoomLevel&quot;: 0,</span><br><span class="line">    &quot;debug.console.fontSize&quot;: 16,</span><br><span class="line">    &quot;debug.console.lineHeight&quot;: 30,</span><br><span class="line">    &quot;[javascript]&quot;: &#123;</span><br><span class="line">        &quot;editor.defaultFormatter&quot;: &quot;HookyQR.beautify&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;[html]&quot;: &#123;</span><br><span class="line">        &quot;editor.defaultFormatter&quot;: &quot;HookyQR.beautify&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在我们的开发环境都已经配置好了，从现在开始，我们就可以happy的编写我们的Go项目啦~~</p><h2 id="Go语言学习资料分享"><a href="#Go语言学习资料分享" class="headerlink" title="Go语言学习资料分享"></a>Go语言学习资料分享</h2><p>到今天，我手上Go语言的学习资料终于整理完了，<strong>有从入门到实战的Go语言教学视频（嫖的某培训班的视频）</strong></p><p><strong>也有从入门到实战再到精通的一条龙技术书籍</strong></p><p>我是属于比较喜欢看书的，对我来说看书的学习效率比看视频要好，但是有的人基础差了点，还是需要看视频，让人手把手带入门才行。所以帮你们嫖了一个全面并且详细的中文视频教程</p><p>你们都知道的，我给你们分享资源，从来就没有什么套路，退出文章后，在我<strong>公众号后台回复「Go资料」</strong>就可以领取下载链接了</p><p>再吐槽一下，百度网盘这货我是彻底抛弃了，因为就算我开了VIP，你们的下载速度还是慢的一匹，并将经常连接中断。</p><p>想想80kb/s的速度就美滋滋，这速度下载10GB的视频资源，明年应该能下载好吧？</p><p>现在换了别的网盘，下载速度的体验还算是可以的，就是有时效性30天，<strong>要是某天下载链接要是失效了，你们私聊我，我就去维护一下。</strong></p><p><img src="http://ww1.sinaimg.cn/large/007OROpSgy1g5pbxlmfqbj306008f0t1.jpg" alt></p><h2 id="关注公众号「闹闹吃鱼」领取更多资源，不仅仅只是技术"><a href="#关注公众号「闹闹吃鱼」领取更多资源，不仅仅只是技术" class="headerlink" title="关注公众号「闹闹吃鱼」领取更多资源，不仅仅只是技术"></a>关注公众号「闹闹吃鱼」领取更多资源，不仅仅只是技术</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/007OROpSgy1g5pd20bhroj30h90d9ag1.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;前几天我聊了聊我自己从一个什么都不懂的小白，到现在只懂一点的学习历程&lt;/p&gt;
&lt;p&gt;所谓万事开头难
      
    
    </summary>
    
      <category term="golang" scheme="https://AdolphKevin.github.io/categories/golang/"/>
    
    
      <category term="VsCode" scheme="https://AdolphKevin.github.io/tags/VsCode/"/>
    
  </entry>
  
</feed>
