<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>闹闹吃鱼</title>
  
  <subtitle>闹闹</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://AdolphKevin.github.io/"/>
  <updated>2019-05-29T16:46:41.231Z</updated>
  <id>https://AdolphKevin.github.io/</id>
  
  <author>
    <name>闹闹</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://AdolphKevin.github.io/2019/05/29/test/index/"/>
    <id>https://AdolphKevin.github.io/2019/05/29/test/index/</id>
    <published>2019-05-29T15:21:19.609Z</published>
    <updated>2019-05-29T16:46:41.231Z</updated>
    
    <content type="html"><![CDATA[<!DOCTYPE html><html lang="en"><head><meta name="generator" content="Hexo 3.8.0">    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>Document</title>    <script type="text/javascript">        window.onload = function () {            function getAllUrlParams(url) {                // 用JS拿到URL，如果函数接收了URL，那就用函数的参数。如果没传参，就使用当前页面的URL                var queryString = url ? url.split('?')[1] : window.location.search.slice(1);                // 用来存储我们所有的参数                var obj = {};                // 如果没有传参，返回一个空对象                if (!queryString) {                    return obj;                }                // stuff after # is not part of query string, so get rid of it                queryString = queryString.split('#')[0];                // 将参数分成数组                var arr = queryString.split('&');                for (var i = 0; i < arr.length; i++) {                    // 分离成key:value的形式                    var a = arr[i].split('=');                    // 将undefined标记为true                    var paramName = a[0];                    var paramValue = typeof (a[1]) === 'undefined' ? true : a[1];                    // 如果调用对象时要求大小写区分，可删除这两行代码                    paramName = paramName.toLowerCase();                    if (typeof paramValue === 'string') paramValue = paramValue.toLowerCase();                    // 如果paramName以方括号结束, e.g. colors[] or colors[2]                    if (paramName.match(/\[(\d+)?\]$/)) {                        // 如果paramName不存在，则创建key                        var key = paramName.replace(/\[(\d+)?\]/, '');                        if (!obj[key]) obj[key] = [];                        // 如果是索引数组 e.g. colors[2]                        if (paramName.match(/\[\d+\]$/)) {                            // 获取索引值并在对应的位置添加值                            var index = /\[(\d+)\]/.exec(paramName)[1];                            obj[key][index] = paramValue;                        } else {                            // 如果是其它的类型，也放到数组中                            obj[key].push(paramValue);                        }                    } else {                        // 处理字符串类型                        if (!obj[paramName]) {                            // 如果如果paramName不存在，则创建对象的属性                            obj[paramName] = paramValue;                        } else if (obj[paramName] && typeof obj[paramName] === 'string') {                            // 如果属性存在，并且是个字符串，那么就转换为数组                            obj[paramName] = [obj[paramName]];                            obj[paramName].push(paramValue);                        } else {                            // 如果是其它的类型，还是往数组里丢                            obj[paramName].push(paramValue);                        }                    }                }                return obj;            }            console.log(getAllUrlParams().name);        }    </script></head><body></body></html>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;&lt;meta name=&quot;generator&quot; content=&quot;Hexo 3.8.0&quot;&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; co
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JS该如何取得URL里的参数？</title>
    <link href="https://AdolphKevin.github.io/2019/05/29/JS%E8%8E%B7%E5%8F%96URL%E5%8F%82%E6%95%B0/"/>
    <id>https://AdolphKevin.github.io/2019/05/29/JS获取URL参数/</id>
    <published>2019-05-29T13:37:59.334Z</published>
    <updated>2019-05-29T17:46:40.331Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/007OROpSgy1g3iprsx176j30gy0cuag2.jpg" alt></p><p>有一段时间没写过技术干货文了，这两天刚好遇到一个以前没太在意的一个功能实现–<strong>前端获取URL传递的参数</strong></p><p>掉了一堆头发后，想想还是写出来跟你们分享一下，以后要是你们遇到了也有个参考</p><p>要只是获取一些常规字符串到没什么难的，关键还有些乱七八糟的需求，什么同一个参数名传递了多次啊，传数组啊。搞来搞去就写了一大堆</p><p>先说说思路吧，<strong>如果你看这文章是想要解决问题，拿着代码直接用的话，就直接看最后面的Code实现以及使用方法吧</strong></p><h2 id="用框架思维分析问题"><a href="#用框架思维分析问题" class="headerlink" title="用框架思维分析问题"></a>用框架思维分析问题</h2><p>给你一个如下的URL：</p><blockquote><p><a href="http://NaoNao.com/?product=shirt&amp;color=blue&amp;newuser&amp;size=m#Hello" target="_blank" rel="noopener">http://NaoNao.com/?product=shirt&amp;color=blue&amp;newuser&amp;size=m#Hello</a></p></blockquote><p>将URL里传递的参数转换为<code>object</code>对象，这样我们在使用参数的时候也更为方便</p><p><strong>我曾多次强调框架思维</strong>，现在遇到这个问题了，我们就拿框架思维来分析一下，该怎样才能快速解决</p><p>首先是要了解我们的<strong>目的是什么</strong>？目的很简单，取得URL内传递的参数，并且解析成对象</p><p>接着再分析<strong>我们现在知道些什么</strong>？有一串URL</p><p>我们再来分析，如果从URL中获得传递的参数，也就是<strong>为了达到目的，我们该做些什么？</strong></p><p>URL的特征我们大致都知道，就是第一个<code>?</code>后面的字符串，都是传递的参数，但是<strong>有个特殊情况请不要忘记了</strong>，URL后面有时候会带上一个<code>#</code>，而<code>#</code>后面的内容，并不是我们要传递的参数，而是网页位置的标识符</p><p>如果URL中包含了<code>#</code>，<strong>我们只需要解析<code>?</code>到<code>#</code>之间的字符串就可以了</strong>，如果不包含，那么第一个<code>?</code>后所有的内容都是我们需要解析的</p><p>你可能觉得我是在说废话，这么明显的事情，只要不是白痴都能看得懂</p><p>我当然知道，只要不是白痴都能看得懂，<strong>但我为什么要强调呢？因为我们想要快速的解决问题，必须具备框架思维，也可以说是工程思维</strong></p><p>你可能有会说，这么简单的问题需要这样分析么？我们一看就知道了，闹闹你这是杀鸡用牛刀</p><p>虽说是杀鸡用牛刀，可<strong>要想培养自己的工程思维，那么必须保持刻意训练，直到随手拈来</strong></p><p>好了，分析完后，我们按照上面的思路来逐步实现，实现的时候可能会遇到其它的问题，到时候再分析，再解决</p><p>毕竟再牛逼的工程师，也不会在动手前就想的面面俱到，只能是<strong>在动手实现前尽可能的考虑周到，遇到问题时再快速的迭代更新</strong></p><h2 id="JS获取URL参数的过程"><a href="#JS获取URL参数的过程" class="headerlink" title="JS获取URL参数的过程"></a>JS获取URL参数的过程</h2><p>先用JS拿到URL，如果函数传参了URL，那就用参数。如果没传参，就使用当前页面的URL<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> queryString = url ? url.split(<span class="string">'?'</span>)[<span class="number">1</span>] : <span class="built_in">window</span>.location.search.slice(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><p>如果后面的字符串存在<code>#</code>，我们还得将<code>#</code>后面的字符串去掉，因为<code>#</code>后面的内容并不是我们需要获取的参数，而是网页位置的标识符</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queryString = queryString.split(<span class="string">'#'</span>)[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>好了，把干扰的部分都移除后，我们可以开始安心的解析参数了，先将传递的参数分成数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = queryString.split(<span class="string">'&amp;'</span>);</span><br></pre></td></tr></table></figure><p>现在我们可以获得一个字符串数组<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'product=shirt'</span>, <span class="string">'color=blue'</span>, <span class="string">'newuser'</span>, <span class="string">'size=m'</span>]</span><br></pre></td></tr></table></figure></p><p>将字符串拆分成数组后，我们通过创建一个对象，用来存储我们所有的参数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br></pre></td></tr></table></figure></p><p>我们可以通过遍历数组<code>arr</code>，将它拆分成键值对。把这个字符串做成<code>key:value</code>的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = arr[i].split(<span class="string">'='</span>);</span><br></pre></td></tr></table></figure><p>接下来就是要为每一个变量<code>key</code>分配对应的值<code>value</code>，如果我们得到的<code>value</code>不是一个正确的参数，我们就用<code>true</code>来表示这个参数名存在，当然了，你也可以根据自己的实际情况来做改变</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> paramName = a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> paramValue = <span class="keyword">typeof</span>(a[<span class="number">1</span>]) === <span class="string">'undefined'</span> ? <span class="literal">true</span> : a[<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>在这里我只是对<code>undefined</code>做了标记，如果是<code>NaN</code>，我是直接拿它当字符串处理了</p><p><strong>在这里有一个小坑得提醒一下</strong>，我们在调用函数，获取对象取值的时候，如果URL传递的<code>key</code>为大写，我们取对象时写的小写，那么结果就是为<code>undefined</code></p><p>比如URL为<code>http://NaoNao.com/?NamE=NaoNao</code>，如果不做大小写的处理，调用对象取值时<code>getAllUrlParams().NamE</code>才能取到值<code>NaoNao</code>，如果做了处理，我们使用时只需要全部写成小写/大写即可，例如<code>getAllUrlParams().name</code></p><p>我在这就全部转为小写了，如果你对大小写要求区分，那到时候把这段Code给去掉就好了<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">paramName = paramName.toLowerCase();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> paramValue === <span class="string">'string'</span>) paramValue = paramValue.toLowerCase();</span><br></pre></td></tr></table></figure></p><p>接下来我们就要去处理我们接受到的<code>paramValue</code>，<strong>这些参数可能是索引数组，非索引数组，又或者是常规字符串</strong></p><p><strong>如果是索引数组</strong>，我们需要将<code>paramValue</code>转换成数组，并且将索引对应的值，放入索引对应的位置</p><p><strong>如果是非索引数组</strong>，我们就要将<code>paramValue</code>放到数组中</p><p><strong>如果只是常规的字符串</strong>，我们就需要为我们的对象<code>obj</code>创建一个常规的属性，并为其分配值。</p><p><strong>如果这个key已经存在</strong>，那么我们就要将现有的<code>paramValue</code>从<code>key:value</code>转换为数组，并将它放到数组中</p><p>拿几个实际案例，感受一下我们要做什么吧</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 索引数组</span></span><br><span class="line">getAllUrlParams(<span class="string">'http://NaoNao.com/?colors[0]=red&amp;colors[2]=green&amp;colors[6]=blue'</span>);</span><br><span class="line"><span class="comment">// &#123; "colors": [ "red", null, "green", null, null, null, "blue" ] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非索引数组</span></span><br><span class="line">getAllUrlParams(<span class="string">'http://NaoNao.com/?colors[]=red&amp;colors[]=green&amp;colors[]=blue'</span>);</span><br><span class="line"><span class="comment">// &#123; "colors": [ "red", "green", "blue" ] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多次传递同一个key</span></span><br><span class="line">getAllUrlParams(<span class="string">'http://NaoNao.com/?colors=red&amp;colors=green&amp;colors=blue'</span>);</span><br><span class="line"><span class="comment">// &#123; "colors": [ "red", "green", "blue" ] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递了key，但是没传value</span></span><br><span class="line">getAllUrlParams(<span class="string">'http://NaoNao.com/?product=shirt&amp;color=blue&amp;newuser&amp;size=m'</span>);</span><br><span class="line"><span class="comment">// &#123; "product": "shirt", "color": "blue", "newuser": true, "size": "m" &#125;</span></span><br></pre></td></tr></table></figure><p>我做这写判断时用的是正则表达式，在这里就不解释正则了。。。毕竟解释起来篇幅就太长了，能看懂就尽量看吧</p><p>每个正则要解析什么，在注释中都写了例子，<strong>稍微了解点正则表达式的同学，多半也能看懂的</strong></p><p>对应的代码实现如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果paramName以方括号结束, e.g. colors[] or colors[2]</span></span><br><span class="line"><span class="keyword">if</span> (paramName.match(<span class="regexp">/\[(\d+)?\]$/</span>)) &#123;</span><br><span class="line">    <span class="comment">// 如果paramName不存在，则创建key</span></span><br><span class="line">    <span class="keyword">var</span> key = paramName.replace(<span class="regexp">/\[(\d+)?\]/</span>, <span class="string">''</span>);</span><br><span class="line">    <span class="keyword">if</span> (!obj[key]) obj[key] = [];</span><br><span class="line">    <span class="comment">// 如果是索引数组 e.g. colors[2]</span></span><br><span class="line">    <span class="keyword">if</span> (paramName.match(<span class="regexp">/\[\d+\]$/</span>)) &#123;</span><br><span class="line">        <span class="comment">// 获取索引值并在对应的位置添加值</span></span><br><span class="line">        <span class="keyword">var</span> index = <span class="regexp">/\[(\d+)\]/</span>.exec(paramName)[<span class="number">1</span>];</span><br><span class="line">        obj[key][index] = paramValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是其它的类型，也放到数组中</span></span><br><span class="line">        obj[key].push(paramValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 处理字符串类型</span></span><br><span class="line">    <span class="keyword">if</span> (!obj[paramName]) &#123;</span><br><span class="line">        <span class="comment">// 如果如果paramName不存在，则创建对象的属性</span></span><br><span class="line">        obj[paramName] = paramValue;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj[paramName] &amp;&amp; <span class="keyword">typeof</span> obj[paramName] === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果属性存在，并且是个字符串，那么就转换为数组</span></span><br><span class="line">        obj[paramName] = [obj[paramName]];</span><br><span class="line">        obj[paramName].push(paramValue);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果是其它的类型，还是往数组里丢</span></span><br><span class="line">        obj[paramName].push(paramValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果你的URL的传参包含了一些特殊字符，比如空格。例如<code>url=&quot;NaoNao.com/?name=Nao%20Nao&quot;</code>，拿到对象值之后，是需要解码后才能获得正确的值的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> original = getAllUrlParams().name; <span class="comment">// 'Nao%20Nao'</span></span><br><span class="line"><span class="keyword">var</span> decode = <span class="built_in">decodeURIComponent</span>(original); <span class="comment">// 'Nao Nao'</span></span><br></pre></td></tr></table></figure><h2 id="具体实现以及使用方式"><a href="#具体实现以及使用方式" class="headerlink" title="具体实现以及使用方式"></a>具体实现以及使用方式</h2><p>下面是JS的具体的完整实现，你们复制回去就可以用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAllUrlParams</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 用JS拿到URL，如果函数接收了URL，那就用函数的参数。如果没传参，就使用当前页面的URL</span></span><br><span class="line">    <span class="keyword">var</span> queryString = url ? url.split(<span class="string">'?'</span>)[<span class="number">1</span>] : <span class="built_in">window</span>.location.search.slice(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 用来存储我们所有的参数</span></span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 如果没有传参，返回一个空对象</span></span><br><span class="line">    <span class="keyword">if</span> (!queryString) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// stuff after # is not part of query string, so get rid of it</span></span><br><span class="line">    queryString = queryString.split(<span class="string">'#'</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 将参数分成数组</span></span><br><span class="line">    <span class="keyword">var</span> arr = queryString.split(<span class="string">'&amp;'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 分离成key:value的形式</span></span><br><span class="line">        <span class="keyword">var</span> a = arr[i].split(<span class="string">'='</span>);</span><br><span class="line">        <span class="comment">// 将undefined标记为true</span></span><br><span class="line">        <span class="keyword">var</span> paramName = a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">var</span> paramValue = <span class="keyword">typeof</span> (a[<span class="number">1</span>]) === <span class="string">'undefined'</span> ? <span class="literal">true</span> : a[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 如果调用对象时要求大小写区分，可删除这两行代码</span></span><br><span class="line">        paramName = paramName.toLowerCase();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> paramValue === <span class="string">'string'</span>) paramValue = paramValue.toLowerCase();</span><br><span class="line">        <span class="comment">// 如果paramName以方括号结束, e.g. colors[] or colors[2]</span></span><br><span class="line">        <span class="keyword">if</span> (paramName.match(<span class="regexp">/\[(\d+)?\]$/</span>)) &#123;</span><br><span class="line">            <span class="comment">// 如果paramName不存在，则创建key</span></span><br><span class="line">            <span class="keyword">var</span> key = paramName.replace(<span class="regexp">/\[(\d+)?\]/</span>, <span class="string">''</span>);</span><br><span class="line">            <span class="keyword">if</span> (!obj[key]) obj[key] = [];</span><br><span class="line">            <span class="comment">// 如果是索引数组 e.g. colors[2]</span></span><br><span class="line">            <span class="keyword">if</span> (paramName.match(<span class="regexp">/\[\d+\]$/</span>)) &#123;</span><br><span class="line">                <span class="comment">// 获取索引值并在对应的位置添加值</span></span><br><span class="line">                <span class="keyword">var</span> index = <span class="regexp">/\[(\d+)\]/</span>.exec(paramName)[<span class="number">1</span>];</span><br><span class="line">                obj[key][index] = paramValue;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是其它的类型，也放到数组中</span></span><br><span class="line">                obj[key].push(paramValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 处理字符串类型</span></span><br><span class="line">            <span class="keyword">if</span> (!obj[paramName]) &#123;</span><br><span class="line">                <span class="comment">// 如果如果paramName不存在，则创建对象的属性</span></span><br><span class="line">                obj[paramName] = paramValue;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj[paramName] &amp;&amp; <span class="keyword">typeof</span> obj[paramName] === <span class="string">'string'</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果属性存在，并且是个字符串，那么就转换为数组</span></span><br><span class="line">                obj[paramName] = [obj[paramName]];</span><br><span class="line">                obj[paramName].push(paramValue);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是其它的类型，还是往数组里丢</span></span><br><span class="line">                obj[paramName].push(paramValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数该怎么使用呢？</p><p>直接把URL参数当成对象调用就OK咯~</p><p>以文章开篇的URL为例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http://NaoNao.com/?product=shirt&amp;color=blue&amp;newuser&amp;size=m#Hello</span></span><br><span class="line"></span><br><span class="line">getAllUrlParams().product; <span class="comment">// 'shirt'</span></span><br><span class="line">getAllUrlParams().color; <span class="comment">// 'blue'</span></span><br><span class="line">getAllUrlParams().newuser; <span class="comment">// true</span></span><br><span class="line">getAllUrlParams().NB; <span class="comment">// undefined</span></span><br><span class="line">getAllUrlParams(<span class="string">'http://NaoNao.com/?NaoNao=shuai'</span>).NaoNao; <span class="comment">// shuai</span></span><br></pre></td></tr></table></figure></p><p>用起来还是很简单方便的吧~</p><h2 id="不兼容IE的解决方案"><a href="#不兼容IE的解决方案" class="headerlink" title="不兼容IE的解决方案"></a>不兼容IE的解决方案</h2><p><strong>如果我们不需要考虑IE这种妖娆贱货，以及一些非常老版本浏览器</strong>，就用浏览器内<code>URLSearchParams</code>的接口吧。。。这个接口可以直接拿取URL内的参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// URL is http://NaoNao.com/?product=shirt&amp;color=blue&amp;newuser&amp;size=m</span></span><br><span class="line"><span class="keyword">const</span> urlParams = <span class="keyword">new</span> URLSearchParams(<span class="built_in">window</span>.location.search);</span><br><span class="line"><span class="comment">// 判断参数是否存在</span></span><br><span class="line"><span class="built_in">console</span>.log(urlParams.has(<span class="string">'product'</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 获取参数对应的值</span></span><br><span class="line"><span class="built_in">console</span>.log(urlParams.get(<span class="string">'product'</span>)); <span class="comment">// "shirt"</span></span><br></pre></td></tr></table></figure><p>这个接口还提供了更多成熟的方法，比如<code>keys()</code>,<code>Values()</code>,还有<code>entries()</code>，这个接口该怎么使用，直接去看官方文档就好了，用起来还是很虚浮的</p><p><img src="http://ww1.sinaimg.cn/large/007OROpSgy1g3ipsgp76nj30am09zgm6.jpg" alt></p><h2 id="微信扫码关注公众号「闹闹吃鱼」，每周都有好分享，还可领取学习资源哦-不仅仅只是技术！"><a href="#微信扫码关注公众号「闹闹吃鱼」，每周都有好分享，还可领取学习资源哦-不仅仅只是技术！" class="headerlink" title="微信扫码关注公众号「闹闹吃鱼」，每周都有好分享，还可领取学习资源哦~不仅仅只是技术！"></a>微信扫码关注公众号「闹闹吃鱼」，每周都有好分享，还可领取学习资源哦~不仅仅只是技术！</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/007OROpSgy1g3iprsx176j30gy0cuag2.jpg&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;有一段时间没写过技术干货文了，这两天刚好遇到一个以前没太在意的一个功能实现–&lt;strong&gt;前端获
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://AdolphKevin.github.io/categories/JavaScript/"/>
    
    
      <category term="URL解析" scheme="https://AdolphKevin.github.io/tags/URL%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>分享一个用Git装逼的小技巧~</title>
    <link href="https://AdolphKevin.github.io/2019/05/26/%E5%88%86%E4%BA%AB%E4%B8%80%E4%B8%AA%E7%94%A8Git%E8%A3%85%E9%80%BC%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7~/"/>
    <id>https://AdolphKevin.github.io/2019/05/26/分享一个用Git装逼的小技巧~/</id>
    <published>2019-05-26T12:46:46.940Z</published>
    <updated>2019-05-26T12:49:58.411Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/15072499-0e0cecc41d7e602b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>上次写完 <a href="https://mp.weixin.qq.com/s?__biz=MzU2NzczMzk5Nw==&amp;mid=2247483753&amp;idx=1&amp;sn=a8d654a7f61833b976f65a9e93b4f56c&amp;chksm=fc99faebcbee73fd8ef1b8bd777f064d90f5a8c5a628da6814065028264b174e09b1b3551176&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">实用且简单的Git教程，轻松搞定多人开发](https://mp.weixin.qq.com/s?__biz=MzU2NzczMzk5Nw==&amp;mid=2247483753&amp;idx=1&amp;sn=a8d654a7f61833b976f65a9e93b4f56c&amp;chksm=fc99faebcbee73fd8ef1b8bd777f064d90f5a8c5a628da6814065028264b174e09b1b3551176&amp;scene=21#wechat_redirect</a>)，得到的反馈信息简直超乎我的预期。</p><p>我前两天登掘金、简书、CSDN上把微信公众号的文章copy过去的时候，那阅读量和点赞数简直亮瞎我了……</p><p>按理来说，写的好，作为我公众号的读者们，你们都是我从别的平台辛辛苦苦一点一点的挖来的，对我更认可才对，居然没几个人给我点「好看」，也没见你们谁分享转发</p><p>我公众号所有文章的点赞数和阅读数全加起来，还不copy过去的文章的十分之一，让我很是伤心啊，点个「好看」表达一下对我文字的认可，我才更有动力写更好的文字与你们分享啊</p><p>作为一个主营微信公众号的号主，要靠别的平台的点赞数据，来获得成就感，我想我也是混的够惨了。</p><p>不过值得欣慰的是，最近有人私信我，跟我说“就是因为看了我那篇文章，才把GIT的命令行给记住的”。听了后我简直高兴的不行</p><p>GIt是个好东西，用了Git后，其它的版本控制器我是觉得真的不好用，而且命令行操作更是好用的不得了</p><p>上篇Git的命令行使用，基本已经解决了95%的问题。（只是从开发人员使用的角度）</p><p>这次做一点补充，<strong>再给你们分享个小技巧，巨好用，还能装逼！</strong><br><img src="https://upload-images.jianshu.io/upload_images/15072499-8e3b68ae10645f7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="Git-Log的进阶使用"><a href="#Git-Log的进阶使用" class="headerlink" title="Git Log的进阶使用"></a>Git Log的进阶使用</h2><p>Git查看日志，单独使用<figure class="highlight plain"><figcaption><span>log```来操作，每一个commit信息太多，干扰信息又太多，而且各种分支的合并也看不到，难受的很。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">今天给你们分享一个装逼的命令行，结合上一篇的文章[实用且简单的Git教程，5分钟搞定Git](https://www.jianshu.com/p/a3f0f55c88fb)，现在就完全可以摆脱第三方软件来使用Git了，复制粘贴即可使用</span><br><span class="line"></span><br><span class="line">&gt; git log --graph --pretty=format:&apos;%Cred%h%Creset - %C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit --date=relative </span><br><span class="line"></span><br><span class="line">给你们看看效果，是不是巨牛逼？</span><br><span class="line"></span><br><span class="line">![](https://upload-images.jianshu.io/upload_images/15072499-251d2d176bff7d3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">命令行这么长还这么复杂，我们该怎么记住呢？莫慌，再给你分享一个好东西</span><br><span class="line"></span><br><span class="line">那就是Git的一个别名操作```alias```，使用这个命令，可以极大的提高我们的命令行输入效率</span><br><span class="line"></span><br><span class="line">## alias效率为王</span><br><span class="line"></span><br><span class="line">我们经常使用的命令有```branch```，```checkout```，```commit```之类的，虽然简单，但是输入起来也是麻烦，作为一个程序员，开发程序就是为了提高效率的，能动一下手指解决问题，就绝不动两下，要把「懒」给发挥到极致才行</span><br><span class="line"></span><br><span class="line">比如看下面的例子：</span><br><span class="line"></span><br><span class="line">```git</span><br><span class="line">git config --global alias.ck checkout</span><br><span class="line"></span><br><span class="line">git config --global alias.br branch</span><br><span class="line"></span><br><span class="line">git config --global alias.ck commit</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><p>这样配置好了之后，我们以后使用这些命令，像<figure class="highlight plain"><figcaption><span>checkout```，直接输入```git ck```就能完事。是不是666？</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```alias.xx```点后面的```xx```就代表了我们设置的别名，使用的时候，直接输入别名就好了</span><br><span class="line"></span><br><span class="line">像上面那么长的```git log```，咱们完全就可以使用```alias```来提高效率，下面的命令行直接复制粘贴就能使用了~</span><br><span class="line"></span><br><span class="line">若是你不做任何修改，使用的时候输入```git lg```即可</span><br><span class="line">```git</span><br><span class="line">git config --global alias.lg &quot;log --graph --pretty=format:&apos;%Cred%h%Creset - %C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit --date=relative&quot;</span><br></pre></td></tr></table></figure></p><p>配个图给你们看看</p><p><img src="https://upload-images.jianshu.io/upload_images/15072499-1dc99c74735ed04f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>执行后，使用的时候直接打开控制台输入<code>git lg</code>即可，又装逼，又省事</p><p>顺便提示一下，Git的命令行操作时，复制是<code>ctrl+insert</code>，粘贴是<code>shift+insert</code>，查看日志时，按「回车键」可以加载更多日志信息，按<code>q</code>键是退出日志查看</p><p>在<code>merge</code>后的<code>commit</code>，偶尔会弹出一个Linux对话框让你写备注</p><p>此时需要用到Linux指令才能操作</p><p>按<code>i</code>进入对话框编辑模式，将<code>commit</code>的备注内容写好后<br>按<code>ESC</code>退出编辑模式<br>按<code>:</code>+<code>wq</code>退出并保存即可</p><h2 id="为什么要用命令行？"><a href="#为什么要用命令行？" class="headerlink" title="为什么要用命令行？"></a>为什么要用命令行？</h2><p>你们应该都知道，<strong>第三方界面化软件操作Git，本质上其实都是用的Git命令行，一些复杂的操作都是直接将GIT组合好后直接执行</strong>，只是软件把他们封装了起来，没让我们看到命令行罢了</p><p>之前我也是用可视化的第三方软件来使用Git命令行的操作，后来发现总是有着莫名其妙的问题，并且错误提示看起来就是一头雾水，后来干脆就学着使用命令行操作</p><p>使用命令行之后才发现，执行的速度以及准确度，<strong>比用第三方软件的效率要高的多</strong>，并且一些莫名其妙的问题也再也没遇见过了</p><p>因为软件是把一系列的Git命令给封装起来，而我们自己使用的时候，Git提交的逻辑顺序我们是很清楚的，这样一步一步走下来，只要逻辑是对的，就不会出错，就算出错了，<strong>命令行操作时，错在哪，该怎么修正，都提示的一清二楚</strong>，这也省下了我们拿着界面化软件的报错去找百度的时间。</p><p>刚开始用命令行操作的时候，是有一些不大习惯，但是用熟练之后，你完全就不会想打开第三方软件了~</p><p>当然了，<strong>技术只是一个工具，工具的目的就是为了提升效率</strong>，如果觉得使用GUI界面化的软件你的效率更高，那就按照自己的高效率方式去做就好了。</p><p>像我，我就是在追求效率的同时，还想着要能装装逼~~</p><p>我做为一个依赖Windows生态的码畜，一切都是可视化操作，唯一能有点能像电影里极客样的样子，也就是用Git命令行的时候了……</p><p>毕竟每次用Git时，屏幕上的命令框里，突突突的跳出这些命令，感觉自己就像电影里的极客那样帅</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>今天周末，也就是爬上来跟你们聊会儿，顺便分享两个小技巧。以后不出意外每周都会这样，当然了，我是指每周分享个小技巧什么的，心情不错的时候，就顺带逼逼叨一下</p><p>分享的小技巧什么的，分享的范围你们可以后台留言告诉我你们想要看什么方面的，我就多写写你们想要看的，反正趁着现在关注我的人不多，基本上每个人都能照顾到，现在不压榨我，还等什么时候呢？</p><p><img src="https://upload-images.jianshu.io/upload_images/15072499-3437bf10840001c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h4 id="扫描关注微信公众号「闹闹吃鱼」，每天都有好分享"><a href="#扫描关注微信公众号「闹闹吃鱼」，每天都有好分享" class="headerlink" title="扫描关注微信公众号「闹闹吃鱼」，每天都有好分享"></a>扫描关注微信公众号「闹闹吃鱼」，每天都有好分享</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/15072499-0e0cecc41d7e602b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240
      
    
    </summary>
    
      <category term="Git教程" scheme="https://AdolphKevin.github.io/categories/Git%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Git" scheme="https://AdolphKevin.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>为什么你的想法那么容易动摇？</title>
    <link href="https://AdolphKevin.github.io/2019/05/25/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E7%9A%84%E6%83%B3%E6%B3%95%E9%82%A3%E4%B9%88%E5%AE%B9%E6%98%93%E5%8A%A8%E6%91%87%EF%BC%9F/"/>
    <id>https://AdolphKevin.github.io/2019/05/25/为什么你的想法那么容易动摇？/</id>
    <published>2019-05-24T16:06:39.000Z</published>
    <updated>2019-05-26T03:45:55.586Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/15072499-99914df46f630528.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信公众号：闹闹吃鱼"></p><blockquote><p>不知道大家有没有看过《奇葩说》，每当看到论题时，其实自己心中已有答案，但是随着双方的不断辩论，过程中自己的想法却也在不断的动摇，改变。更在有的时候，甚至会怀疑自己</p></blockquote><p>自己的观点不断随着外界因素的改变，是一件坏事情么？</p><p>自己观点容易动摇，最主要原因就是自己习惯性的思维方式，思维方式决定了我们最后所作的决定</p><p>有两种常见是思维方式，分别就是<strong>海绵式思维</strong>与<strong>淘金式思维</strong></p><h2 id="什么是海绵式思维？"><a href="#什么是海绵式思维？" class="headerlink" title="什么是海绵式思维？"></a>什么是<strong>海绵式思维</strong>？</h2><p>先来谈谈<strong>海绵式思维</strong></p><p>想想在我们刚进入某个行业开始学习的时候，面对一切的知识，面对权威、对书本的内容深信不疑。</p><p>自己就是像一块会吸水的海绵一样，想把一切都吸收进自己的身体里</p><p>这样做并不是没好处，有两个极大的优点</p><ul><li>可以快速的学习知识，吸收外部信息越多，越能体会到其中的千头万绪，为之后的复杂思考提供了坚实的基础</li><li>可以快速的学习高手的知识、思想，为我们成为一个有思想的人，奠定了一定高度的基础。</li></ul><p>不过这世界总是公平的，这货有如此好处的同时，还有一个非常致命的缺点：面对纷沓而来的各种信息，<strong>这种思维方式对我们进行信息的取舍提供不了任何帮助</strong>。如果我们始终依赖<strong>海绵式思维</strong>学习，那么我们在学习的道路上，对最新学习的内容将深信不疑。</p><p>为什么海绵式思维不能让我们对信息做出取舍呢？因为它本身是一种被动的学习方式，被动的学习，我们只需要认真理解并记忆，他们的知识就能被我们“学会”。</p><p>被动学习是轻松并愉快还高效的一种方式，不需要我们对各种信息进行深入的思考与求证，尤其是面对他人拿出井井有条并生动有趣的论证过程时，我们更是对之论证结果深信不疑。</p><p>可是，不管是在学习时，还是在人生路上，我们都要自己掌握主动权，我们的人生要我们自己主宰，享受过被动学习的快速与高效后，我们要建立起自己的世界观，转被动为主动。</p><h2 id="淘金式思维"><a href="#淘金式思维" class="headerlink" title="淘金式思维"></a><strong>淘金式思维</strong></h2><p>要说转被动为主动，那肯定离不开一个概念词<strong>淘金式思维</strong></p><p>淘金式思维是一种主动的思维形式，何为主动？就是我们需要知道，哪些东西是重要的，哪些东西是不重要的，选择重要的东西，抛弃无所谓的东西。</p><p>这个名词其实就已经非常的形象的解释了什么是主动，就像沙海中淘金，把廉价的沙石去除，只留下珍贵的黄金。反正黄金自己是不会从沙海中跑你手上的。</p><p>主动学习无疑是辛苦的，因为需要我们主动思考，依赖于自己的人生观、世界观、价值观等因素，去思考什么东西才是正确的，什么东西是值得学习的。</p><p>而不像被动学习那样胡吃海喝，什么都要。</p><p>在如今这个信息爆炸的时代，淘金式思维不仅能很好的帮助我们与对方进行互动，更能帮助我们筛选无用信息。</p><p>在互动的过程中，难免会对观点或者内容有着的不同见解，当在不同见解中找不同时，双方都能有更多的收获。</p><p>要说筛选无用信息，近两天登上微博热搜榜的《搜索引擎百度已死》一文，主要说了搜索引擎百度，在信息搜索时得到的结果良莠不齐，甚至低劣内容占据更多的搜索结果。</p><p>文中作者能判断内容优劣，无非就是利用淘金式思维做了筛选。</p><p>介绍了这么多两种思维的差距以及优劣，那我们该怎么培养<strong>淘金式思维</strong>呢？</p><p>其实培养淘金式思维也并非难事，归根结底，只是需要我们培养自己的主动意识。那该怎么主动呢？继续往下看就知道了</p><h2 id="批判性思维"><a href="#批判性思维" class="headerlink" title="批判性思维"></a>批判性思维</h2><p>说了这么多，都是为了给<strong>批判性思维</strong>做铺垫的。</p><p>不知道你们有没有遇到这种困惑？</p><blockquote><p>自己不论是小到物品选购，还是大到报考学校专业选择，只要自己在选择前，在网络上搜集了大量资料，或者咨询了周边亲戚朋友的各种建议之后，自己更是无法选择。</p></blockquote><p>因为这种情况就是因为我们没有自己的<strong>批判性思考</strong>，在信息大爆炸的时代背景下，我们需要能够自己独立思考，只有当我们有了自己的思考后，才能发出自己的声音。</p><p>上面介绍的海绵式思维与淘金式思维，两者都没有绝对的好处，没有谁能替代谁。</p><p>在批判性思维中，上述两种思维是需要综合运用的。在我们知识匮乏时，需要通过海绵式思维来快速积累自己的知识，当有了一定的知识储备后，自然就能建立起我们对内容的认知。</p><p>有了这些知识储备做为我们的基础，我们才有能力去对别的内容进行判断，才能拥有我们的自己的思想。</p><p>但是在使用批判式思维时，不要陷入了自己的思维陷阱中。看看高级与低级的区分，自然也就明白陷阱是什么</p><p>在Wiki百科中，对拥有批判思考者的高低，有着以下的定义</p><blockquote><p><strong>低级的批判思考者</strong>(即持有弱批判性思维者)人们称作「诡辩家」，他们有娴熟的思考技巧，却不管自身思维是否有明显问题，他们善于挖掘他人的思考漏洞，用种种手段、技巧赢得辩论、打动他人、谋取利益。  </p><p><strong>高级的批判思考者</strong>(即持有强批判性思维者)是公正无私的，他们试图评论一切推理的真正优点与缺失，无论出于自己或他人。他们不会控制他人或逃避真相，而是用有道德、负责任的态度思考问题，他们愿意聆听自己未必赞同的论点，如有更正确的推理，也愿意改变自己的观点或立场。</p></blockquote><p><strong>总结而言，我们需要时刻使用批判性思维看待自己的思维是否有问题。</strong></p><p>我们不能也不应该逃避真相，我们培养自己的批判性思维，不就是为了我们自己能在这信息错综复杂的时代拥有自己的思想，找到真相从而不随意被他人蛊惑吗？</p><p>好了，扯了这么多的内容，你能看到这，我觉得我们对<strong>海绵式思维</strong>，<strong>淘金式思维</strong>，<strong>批判性思维</strong>已经达成共识了。</p><p>那我就在这说说该怎么<strong>具体应用批判性思维</strong>吧</p><h2 id="批判性思维的具体应用"><a href="#批判性思维的具体应用" class="headerlink" title="批判性思维的具体应用"></a>批判性思维的具体应用</h2><p>在还未习惯批判性思维的思考方式时，我们需要找到套路，毕竟在没有自己的经验之前，学习前人的经验是最快且有成效的一种方式</p><p>先来看看套路是怎样的，我的总结如下三点</p><blockquote><ul><li>找观点</li><li>看结论</li><li>支撑观点的理由是逻辑正确</li></ul></blockquote><p>先来看一个例子，从实际情况出发，结合上面的套路，我们来看看实际情况是到底是怎样的。<br>以下实践用例引用于《学会提问》（第十版）</p><blockquote><p>学校的着装规定是对不当着装的限制，目的是营造一种专心致志的学习氛围。如果一个学生衣着不当地来上课，就有可能极大的分散其他同学的注意力。在校期间适用着装规定并不是限制学生的表达自由。不同于要求学生统一着装，着装规定仍旧允许学生自由选择自己的服装，只要不是被视为不当着装即可。</p></blockquote><p>咱们按照上述套路来解析一下上述的观点说明。（以下解析为我个人解析，并非书本中的解析）</p><p><strong>观点：</strong>学校该不该对着装有着限制？</p><p><strong>结论：</strong>学校应该限制学生的不当着装。</p><p><strong>理由：</strong>不当着装会影响学校的学习氛围，分散同学的注意力</p><p>将问题清晰的剥离出来后，我们就可以在我们现有的知识体系上去判断此结论是否成立</p><p>首先我们需要与表达者达成共识，什么才算是”不当着装”？这点在与作者达成共识之前，我们并不好否定或者承认其结论的正确与错误。<br>因为在某些人眼中，在不管男士女生，裤子没遮住膝盖，就属于不正当着装。<br>又或者在有些人眼中，衣服上写着不利于社会主义的话，才算是不正当着装。</p><p>再来看逻辑是否正确，学生的穿衣为什么会影响学校的学习氛围呢？<br>这个理由本是用来支撑“学校应该限制学生的不当着装”的结论，而这结论又是从何而来？<br>如果我相信这个结论是正确的，那为了考虑别的同学的正常学习，学校应该限制学生的不当着装自然也应该支持。<br>可我要是不相信不当着装会影响学习氛围，那后续的结论自然也就不成立了。</p><p>看完上述这个例子，我想你对批判性思维自然也会有了一些理解。</p><p>无非就是按照上面总结的套路来，生活中多思考，多运用。你会发现之后看到的世界，与你现在看到的世界，有了很大的不一样。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>每一个人都应该学会批判性思维，反复求证自己的观点的同时，也能更准确的分辨哪些人是在胡说八道，哪些人说的观点是真的有价值。</p><p>快过年了，不管是正儿八经的公司，还是邪门歪道的骗子。都想着冲一把业绩过个好年。大家正好可以多用用批判性思维，去辨别哪些是想收割你的骗子，哪些是想教你钓鱼</p><p><strong>一个观点只有经过自己不断的反复论证与修改，最后才能成为自己的信念</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/15072499-d1676893bc8c464d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="关注微信公众号「闹闹吃鱼」，每周都有好分享，还可领取学习资源哦！"><a href="#关注微信公众号「闹闹吃鱼」，每周都有好分享，还可领取学习资源哦！" class="headerlink" title="关注微信公众号「闹闹吃鱼」，每周都有好分享，还可领取学习资源哦！"></a>关注微信公众号「闹闹吃鱼」，每周都有好分享，还可领取学习资源哦！</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/15072499-99914df46f630528.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240
      
    
    </summary>
    
      <category term="认知提升" scheme="https://AdolphKevin.github.io/categories/%E8%AE%A4%E7%9F%A5%E6%8F%90%E5%8D%87/"/>
    
    
      <category term="批判性思维" scheme="https://AdolphKevin.github.io/tags/%E6%89%B9%E5%88%A4%E6%80%A7%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>实用且简单的Git教程，5分钟搞定Git</title>
    <link href="https://AdolphKevin.github.io/2019/05/25/%E5%AE%9E%E7%94%A8%E4%B8%94%E7%AE%80%E5%8D%95%E7%9A%84Git%E6%95%99%E7%A8%8B%EF%BC%8C5%E5%88%86%E9%92%9F%E6%90%9E%E5%AE%9AGit/"/>
    <id>https://AdolphKevin.github.io/2019/05/25/实用且简单的Git教程，5分钟搞定Git/</id>
    <published>2019-05-24T16:00:00.000Z</published>
    <updated>2019-05-26T12:48:16.542Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/15072499-7f52aff5e9ee727d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><p>俗说金三银四，大部分人都选择在这个时候找工作</p><p>有拿完年终奖准备跳槽的，也有年前就辞职，已经休了一个长期年假的，还有刚走出校门的青涩少年们</p><p>换了新工作，肯定要接触新项目，现在绝大多数项目都是使用Git进行版本控制</p><p>这篇文章，<strong>主要目的是在多人开发中让你能熟练使用Git</strong></p><p>从实战出发，不大谈原理，只谈实际应用，省去大量的查找文档的时间</p><p>入职新公司，接触新项目，基本是不需要你自己搭建Git项目来托管code的，所以这里就不谈搭建了，只谈在开发实战时，如何使用Git</p><p>文末有总结，便于查阅</p><p><strong>第一件事，肯定就是先安装Git了</strong></p><p>官网下载Git比较麻烦，需要有梯子来帮助你，才能摸到它，这里直接给你一个Github上的镜像地址供你下载安装</p><blockquote><p><a href="https://github.com/waylau/git-for-win" target="_blank" rel="noopener">https://github.com/waylau/git-for-win</a></p></blockquote><p>若不会安装，请移步搜索引擎，搜索Git安装教程，本文不过多描述安装过程</p><h2 id="第一次使用Git"><a href="#第一次使用Git" class="headerlink" title="第一次使用Git"></a>第一次使用Git</h2><p>安装好后，直接打开Git Bash，也就是Git 的控制台程序，就可以开始使用了</p><p>第一次使用Git，需要先配置自己的邮箱与名称</p><p>配置邮箱地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email &quot;NaoNao.@nao.com&quot;</span><br></pre></td></tr></table></figure></p><p>配置用户名<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;NaoNao&quot;</span><br></pre></td></tr></table></figure></p><p>配置完，Git不会给出任何提示，Unix的逻辑就是，没有提示就是最美的提示。</p><p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><p>要想查看是否配置成功，依然是使用上述命令，把引号以及引号内的内容去掉即可。</p><h2 id="拉取项目"><a href="#拉取项目" class="headerlink" title="拉取项目"></a>拉取项目</h2><p>配置好我们的个人信息后，自然也就需要拉取项目了</p><p>在磁盘中新建好存放项目的文件夹，进入文件夹点击鼠标右键，选择Git Bash即可</p><p>温馨提示：使用Git托管的项目，有两种地址，Https与SSH。</p><p><strong>使用Https地址</strong>拉取，验证一次密码后，以后每次拉取/推送的时候不再需要验证密码。</p><p><strong>使用SSH地址</strong>拉取的项目，每次拉取/推送的时候都需要密码验证。<br>各位读者自己抉择。</p><p>我的项目地址是 <a href="https://github.com/AdolphKevin/NaoNao.git" target="_blank" rel="noopener">https://github.com/AdolphKevin/NaoNao.git</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/AdolphKevin/NaoNao.git</span><br></pre></td></tr></table></figure></p><p>将你的项目地址替换掉我的项目地址即可</p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>说分支管理之前，在此做个<strong>背景说明</strong>：一般在项目开发中会有2个主分支（master与develop）</p><p>master分支上的内容是发布在<strong>生产环境</strong>运行的内容</p><p>develop分支是所有开发人员<strong>开发完成</strong>发布到测试环境的内容</p><p>其它各种feature分支都是各位开发人员在开发时拉取使用的分支</p><p>此文，也沿用此方式，各位读者按照自己实际情况判断</p><p>拉取下来后，我们要进行开发，肯定不能在master分支上开发，一般在项目上都会有各种分支</p><p>项目clone下来，首先就是查看分支了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure></p><p>加上-r是代表查看远程仓库的分支，要是查看本地分支，只需要把-r去掉即可，-r是remote的简写</p><p>查看远程分支，所有的分支名前均会带有origin/ 的前缀，这个前缀代表着远程分支，拉取远程分支，填写远程分支名时不需要带上origin/</p><p>接到开发任务，我们需要从远程仓库上将我们需要开发的分支拉取到本地<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin x(远程分支名):y(本地分支名)</span><br></pre></td></tr></table></figure></p><p>使用上述代码，可以将远程分支拉取到本地，并创建本地分支</p><p>接着就是要将刚刚创建的本地分支与远程分支做关联了，做了关联之后，拉取更新与推送都不需要再指定分支名称<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream-to=origin/x(远程分支名)  y(本地分支名)</span><br></pre></td></tr></table></figure></p><p>其中，x是你本地分支对应的远程分支；y是你当前的本地分支。</p><h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><p>做完关联后，咱们就需要切换分支，在特定的分支上去进行开发任务<br>先查看本地分支，找到我们需要开发的分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></p><p>再切换到我们需要开发的分支上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout y(分支名)</span><br></pre></td></tr></table></figure></p><h2 id="提交内容"><a href="#提交内容" class="headerlink" title="提交内容"></a>提交内容</h2><p>我们在自己的分支上按照需求完成了开发任务，接着就是将我们开发的内容提交到远程仓库了</p><p>虽然咱们所在的分支，除了自己之外，按理说是没人会在自己这个分支上再进行开发，所以推送前拉取更新也不很必要</p><p>但是为了避免不必要的麻烦，提交之前还是先拉取一下最新的数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure></p><p>获取了最新数据后，如果有别的同事动了咱们的分支，那肯定得先解决一下文件的冲突，若没有人动，那也就不用处理了</p><p>接着将我们添加/修改的文件提交到本地暂存区<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add xxx(文件名)</span><br></pre></td></tr></table></figure></p><p>xxx代表着文件名。当然，开发时咱们基本上很少只修改/添加一个单独的文件，当修改或添加了很多文件时，让我们一个一个文件的add，能把人给累死</p><p>所以Git也给出了批量add的方法，简单粗暴<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -A</span><br></pre></td></tr></table></figure></p><p>-A是All的缩写，git add all 可以提交未跟踪、修改和删除文件。<br>.git add . 可以提交未跟踪和修改文件，但是不处理删除文件。</p><p>提交到暂存区后完成后就是将改动内容全部提交<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;提交到暂存区&quot;</span><br></pre></td></tr></table></figure></p><p>引号内的文字，是此次提交内容的一个说明描述，以后看日志时也便于知道此次进行了什么内容的修改</p><p>提交完后就是将本次修改的内容推送至远程仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure></p><p>好了，到这里push的时候，坑来了~~~</p><p>如果是自己一个人的项目，此时如何push都没问题，但问题就出在，咱们是多人开发的项目，咱们的分支是需要与主分支合并(merge)。</p><p>别的同事的任务完成了，早已推送到我们将要合并的develop分支上了</p><p>所以我们在push之前需要进行code merge ，将develop分支上的内容merge到我们当前的feature分支上</p><h2 id="代码合并"><a href="#代码合并" class="headerlink" title="代码合并"></a>代码合并</h2><p>此时我们在feature分支上已经将修改内容commit了<br>需要将develop分支的内容合并到当前分支，先切换分支到develop上，再获取一次更新<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure></p><p>这里切换到develop分支上获取更新时有个小坑，咱们暂且按照一切顺利来处理，后面再说一些常见的意外情况的处理。</p><p>获取完更新后，再切换到我们的feature分支上，将develop的内容合并到我们的feature分支上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature</span><br></pre></td></tr></table></figure></p><p>合并某分支到当前分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge develop</span><br></pre></td></tr></table></figure></p><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>执行merge后，如果有冲突，控制台会将有冲突的文件名展示出来，我们按照文件名找到对应文件，将冲突给解决掉后。</p><p>打开文件我们可以看到冲突的内容，例如：</p><blockquote><p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>hello world feature<br>\=======<br>hello world develop<br>>&gt;&gt;&gt;&gt;&gt; develop</p></blockquote><p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容</p><p><code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;与=======之间</code>的内容为<strong>当前分支</strong>的内容</p><p><code>=======与&gt;&gt;&gt;&gt;&gt;&gt;</code>之间的内容为<strong>develop分支</strong>的内容（换句话说：就是需要<strong>被合并的分支</strong>内容）</p><p><strong>将不需要保留的内容删除即可解决冲突</strong></p><p>解决冲突后，我们再将当前的feature分支推送到远程仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure></p><p>执行完本命令行后，即可将本地分支内容推送至远程仓库</p><h2 id="获取更新时的意外情况"><a href="#获取更新时的意外情况" class="headerlink" title="获取更新时的意外情况"></a>获取更新时的意外情况</h2><p>前面说从feature分支切换到develop分支拉取更新时，会有个小坑，因为有时候Git会报错</p><blockquote><p>Git pull - Please move or remove them before you can merge</p></blockquote><p>这个错误是因为无论原始文件中.gitignore 文件的内容是什么，文件都被添加到远程存储库中。</p><p>由于文件存在于远程存储库中，因此git也必须将它们提取到本地工作树，因此会抱怨文件已经存在。 </p><p>.gitignore 仅用于扫描新添加的文件，它与已添加的文件没有任何关系。</p><p>因此，解决方案是删除工作树中的文件并提取最新版本。或者长期解决方案是如果错误地添加了文件，则从存储库中删除文件。</p><p>这时我们在develop 分支上删除当前目录下没有被track过的文件和文件夹<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clean -d -f</span><br></pre></td></tr></table></figure></p><p>现在重新获取更新即可</p><h2 id="开发到一半，却需要切换分支"><a href="#开发到一半，却需要切换分支" class="headerlink" title="开发到一半，却需要切换分支"></a>开发到一半，却需要切换分支</h2><p>软件开发中，Bug就像家常便饭一样。有了Bug就需要修复，在Git中，由于分支是如此的强大，所以，在实战中，每个Bug都是通过一个新的临时分支来修复，修复后，将Bug分支合并到develop与master两个分支上，然后将临时分支删除</p><p>注意：将Bug分支合并到develop与master两个分支上，是在远程仓库完成。在本地，是需要将develop与master分支先获取最新，然后将这两分支分别合并在Bug分支上，解决冲突后直接推送Bug分支即可</p><p>可我们在feature分支上开发功能开发到一半，leader突然跑来告诉我们，生产环境出现了一个Bug，需要咱们紧急修复，咱们兴致勃勃的使用<code>git checkout Bug</code>命令，打算切换到Bug分支上去修复Bug</p><p>结果……Git却告诉我们，无法切换过去，因为我们目前所在分支没有提交……</p><p>可我们若要完成开发任务再去修复Bug，可能需要好几个小时甚至几天时间才能完成，而Bug修复却是紧急任务，这该如何是好呢？</p><p>问题不大，不慌。此时我们可以将当前分支开发的工作状态储藏下来，待我们解决了Bug，再恢复我们现在的状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure></p><p>执行完上述命令后，我们再来看看我们工作区是否干净<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></p><p>我们发现工作区非常干净，此时我们就可以顺利的执行<figure class="highlight plain"><figcaption><span>checkout Bug```到Bug分支上去修改Bug了</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">咱们现在将Bug也解决了，也推送了，现在又回到feature分支继续咱们之前的任务了，切换回feature分支后，之前修改的内容也没有恢复啊！说好的储藏了工作状态呢？</span><br><span class="line"></span><br><span class="line">咱们就来看看所有储藏的工作</span><br><span class="line">```git</span><br><span class="line">git stash list</span><br></pre></td></tr></table></figure></p><p>使用上述命令，Git会将所有的储藏工作罗列出来，当我们想要恢复其中某一个储藏状态时，指定其名字就好了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure></p><p>上述的stash@{0} 是当前分支储藏的工作名，各位读者根据自己的<figure class="highlight plain"><figcaption><span>stash list ```中的内容，自行替换</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">切换后，确认完当前状态无误了，就可以将之前保存的储藏删除</span><br><span class="line">```git</span><br><span class="line">git stash drop stash@&#123;0&#125;</span><br></pre></td></tr></table></figure></p><p>觉得要执行两行命令比较麻烦？没关系，还有一次性解决问题的方法<br>切换后并自动删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git stash pop stash@&#123;0&#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><p>不过我个人不大推荐这种方式，万一咱们恢复的储藏指定错了呢，要恢复起来还挺麻烦的。</p><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>在开发时，总有需要回退到某个版本的时候，不然用版本控制系统干嘛？是吧</p><p>我们先来看看我们的历史版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure></p><p>现在控制台输出了最近三次提交的日志信息，友情提示一下，按键盘Q可退出，按回车可查看更多的日志</p><p>要是嫌弃输出的内容过于冗杂，可以让Git显示个简单版<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=oneline</span><br></pre></td></tr></table></figure></p><p>加上一个<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">现在我们可以根据当时commit时填写的描述信息，来判断哪一个ID是我们想要回退的版本</span><br><span class="line"></span><br><span class="line">版本的回退，有两种常用的方式</span><br><span class="line"></span><br><span class="line">回退到上一个版本</span><br><span class="line">```git </span><br><span class="line">git reset --hard HEAD</span><br></pre></td></tr></table></figure></p><p>根据commit的ID，回退到指定版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard commit_id</span><br></pre></td></tr></table></figure></p><p>commit_id这个版本号没必要写全，只需要写6位以上就差不多了，Git能自己找到它，若存在前6位重复ID，那再多加几位就好了</p><p>版本的回退也非常的简单吧，Git的命令行操作写到这儿，也进入尾声了。上述的命令基本可以满足日常的使用</p><h2 id="写在最后的总结"><a href="#写在最后的总结" class="headerlink" title="写在最后的总结"></a>写在最后的总结</h2><p>Git命令行的操作，使用起来并不复杂，作为开发人员，要是没有深入了解Git的意愿，会用就行了，使用Git的要领就是大量使用分支<br>总结一下本文牵扯到的git操作<br><code>git config --global user.name</code>查看用户名或配置用户名</p><p><code>git config --global user.email</code>查看email或配置email</p><p><code>git clone</code>将远程仓库的项目克隆到本地</p><p><code>git branch</code>查看分支</p><p><code>git branch -r</code>查看远程分支</p><p><code>git branch &lt;name&gt;</code>创建分支</p><p><code>git fetch origin origin/remote_branch:your_branch</code>将远程分支下载到本地，并创建分支</p><p><code>git branch --set-upstream-to=origin/remote_branch  your_branch</code>将本地分支与远程分支做关联</p><p><code>git pull</code>获取更新</p><p><code>git clean -d -f</code>删除当前目录下没有被track过的文件和文件夹</p><p><code>git merge &lt;name&gt;</code>将目标分支合并到当前分支</p><p><code>git add</code>将内容添加到暂存区</p><p><code>git commit</code>将添加的内容提交</p><p><code>git push</code>将本地提交内容推送到远程仓库</p><p><code>git checkout</code>切换分支</p><p><code>git branch -d &lt;name&gt;</code>删除分支</p><p><code>git stash</code>储藏当前分支所有内容</p><p><code>git stash list</code>查看当前分支储藏列表</p><p><code>git stash apply</code>恢复指定储藏内容</p><p><code>git stash drop</code>删除指定储藏内容</p><p><code>git stash pop</code>恢复并删除指定储藏内容</p><p><code>git status</code>显示工作目录和暂存区的状态</p><p><code>git log</code>显示commit的详细日志</p><p><code>git log --pretty=oneline</code>只显示commit的ID与描述</p><p><code>git reset --hard HEAD</code>回退到最近的一个版本</p><p><code>git reset --hard commit_id</code>根据commit_id回退到指定版本</p><p><img src="https://upload-images.jianshu.io/upload_images/15072499-bf1cf0945c3963a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h2 id="关注微信公众号「闹闹吃鱼」，每周都有好分享，还可领取学习资源哦！"><a href="#关注微信公众号「闹闹吃鱼」，每周都有好分享，还可领取学习资源哦！" class="headerlink" title="关注微信公众号「闹闹吃鱼」，每周都有好分享，还可领取学习资源哦！"></a>关注微信公众号「闹闹吃鱼」，每周都有好分享，还可领取学习资源哦！</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/15072499-7f52aff5e9ee727d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240
      
    
    </summary>
    
      <category term="Git教程" scheme="https://AdolphKevin.github.io/categories/Git%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Git" scheme="https://AdolphKevin.github.io/tags/Git/"/>
    
  </entry>
  
</feed>
